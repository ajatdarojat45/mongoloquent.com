---
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Sponsor from "./sponsor.mdx";

# Collections

## Introduction

The `Collection` class provides a fluent, convenient wrapper for working with arrays of data. For example, check out the following code. We'll use the collect helper to create a new collection instance from the array.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { collect } from "mongoloquent";

    interface IData {
      foo: string;
    }

    const collection = collect<IData>([{foo: "Ajat"}, {foo: "Udin"}])
    .where("foo", "Ajat")
    .map((item) => item.foo.toUpperCase());
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { collect } from "mongoloquent";

    const collection = collect([{foo: "Ajat"}, {foo: "Udin"}])
    .where("name", "Ajat")
    .map((item) => item.foo.toUpperCase());
    ```

  </TabItem>
</Tabs>

As you can see, the `Collection` class allows you to chain its methods to perform fluent mapping and reducing of the underlying array. In general, collections are immutable, meaning every `Collection` method returns an entirely new `Collection` instance.

### Creating Collections

As mentioned above, the `collect` helper returns a new `Collection` instance for the given array. So, creating a collection is as simple as:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { collect } from "mongoloquent";

    interface IData {
      foo: string;
    }

    const collection = collect<IData>([{foo: "Ajat"}, {foo: "Udin"}])
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { collect } from "mongoloquent";

    const collection = collect([{foo: "Ajat"}, {foo: "Udin"}])
    ```

  </TabItem>
</Tabs>

You may also create a collection using the `make` methods.

> The results `Mongoloquent` queries are always returned as `Collection` instances.

## Available Methods

For the majority of the remaining collection documentation, we'll discuss each method available on the `Collection` class. Remember, all of these methods may be chained to fluently manipulate the underlying array. Furthermore, almost every method returns a new `Collection` instance, allowing you to preserve the original copy of the collection when necessary:

<div style={{ display: "flex", gap: "2rem", flexWrap: "wrap" }}>
	<div style={{ flex: 1, minWidth: "200px", lineHeight: "1.6" }}>
		<div>
			<a href="#after">after</a>
		</div>
		<div>
			<a href="#all">all</a>
		</div>
		<div>
			<a href="#average">average</a>
		</div>
		<div>
			<a href="#avg">avg</a>
		</div>
		<div>
			<a href="#before">before</a>
		</div>
		<div>
			<a href="#chunk">chunk</a>
		</div>
		<div>
			<a href="#chunkWhile">chunkWhile</a>
		</div>
		<div>
			<a href="#collapse">collapse</a>
		</div>
		<div>
			<a href="#collapseWithKeys">collapseWithKeys</a>
		</div>
		<div>
			<a href="#collect">collect</a>
		</div>
		<div>
			<a href="#combine">combine</a>
		</div>
		<div>
			<a href="#concat">concat</a>
		</div>
		<div>
			<a href="#contains">contains</a>
		</div>
		<div>
			<a href="#containsOneItem">containsOneItem</a>
		</div>
		<div>
			<a href="#containsStrict">containsStrict</a>
		</div>
		<div>
			<a href="#count">count</a>
		</div>
		<div>
			<a href="#countBy">countBy</a>
		</div>
		<div>
			<a href="#crossJoin">crossJoin</a>
		</div>
		<div>
			<a href="#dd">dd</a>
		</div>
		<div>
			<a href="#diff">diff</a>
		</div>
		<div>
			<a href="#diffAssoc">diffAssoc</a>
		</div>
		<div>
			<a href="#diffAssocUsing">diffAssocUsing</a>
		</div>
		<div>
			<a href="#diffKeys">diffKeys</a>
		</div>
		<div>
			<a href="#doesntContain">doesntContain</a>
		</div>
		<div>
			<a href="#dot">dot</a>
		</div>
		<div>
			<a href="#dump">dump</a>
		</div>
		<div>
			<a href="#duplicates">duplicates</a>
		</div>
		<div>
			<a href="#duplicatesStrict">duplicatesStrict</a>
		</div>
		<div>
			<a href="#each">each</a>
		</div>
		<div>
			<a href="#eachSpread">eachSpread</a>
		</div>
		<div>
			<a href="#ensure">ensure</a>
		</div>
		<div>
			<a href="#every">every</a>
		</div>
		<div>
			<a href="#except">except</a>
		</div>
		<div>
			<a href="#filter">filter</a>
		</div>
		<div>
			<a href="#first">first</a>
		</div>
		<div>
			<a href="#firstOrFail">firstOrFail</a>
		</div>
		<div>
			<a href="#firstWhere">firstWhere</a>
		</div>
		<div>
			<a href="#flatMap">flatMap</a>
		</div>
		<div>
			<a href="#flatten">flatten</a>
		</div>
		<div>
			<a href="#flip">flip</a>
		</div>
		<div>
			<a href="#forget">forget</a>
		</div>
		<div>
			<a href="#forPage">forPage</a>
		</div>
		<div>
			<a href="#fromJson">fromJson</a>
		</div>
		<div>
			<a href="#get">get</a>
		</div>
		<div>
			<a href="#groupBy">groupBy</a>
		</div>
		<div>
			<a href="#has">has</a>
		</div>
		<div>
			<a href="#hasAny">hasAny</a>
		</div>
		<div>
			<a href="#implode">implode</a>
		</div>
		<div>
			<a href="#intersect">intersect</a>
		</div>
		<div>
			<a href="#intersectUsing">intersectUsing</a>
		</div>
		<div>
			<a href="#intersectAssoc">intersectAssoc</a>
		</div>
	</div>
	<div style={{ flex: 1, minWidth: "200px", lineHeight: "1.6" }}>
		<div>
			<a href="#intersectAssocUsing">intersectAssocUsing</a>
		</div>
		<div>
			<a href="#intersectByKeys">intersectByKeys</a>
		</div>
		<div>
			<a href="#isEmpty">isEmpty</a>
		</div>
		<div>
			<a href="#isNotEmpty">isNotEmpty</a>
		</div>
		<div>
			<a href="#join">join</a>
		</div>
		<div>
			<a href="#keyBy">keyBy</a>
		</div>
		<div>
			<a href="#keys">keys</a>
		</div>
		<div>
			<a href="#last">last</a>
		</div>
		<div>
			<a href="#lazy">lazy</a>
		</div>
		<div>
			<a href="#macro">macro</a>
		</div>
		<div>
			<a href="#make">make</a>
		</div>
		<div>
			<a href="#map">map</a>
		</div>
		<div>
			<a href="#mapInto">mapInto</a>
		</div>
		<div>
			<a href="#mapSpread">mapSpread</a>
		</div>
		<div>
			<a href="#mapToGroups">mapToGroups</a>
		</div>
		<div>
			<a href="#mapWithKeys">mapWithKeys</a>
		</div>
		<div>
			<a href="#max">max</a>
		</div>
		<div>
			<a href="#median">median</a>
		</div>
		<div>
			<a href="#merge">merge</a>
		</div>
		<div>
			<a href="#mergeRecursive">mergeRecursive</a>
		</div>
		<div>
			<a href="#min">min</a>
		</div>
		<div>
			<a href="#mode">mode</a>
		</div>
		<div>
			<a href="#multiply">multiply</a>
		</div>
		<div>
			<a href="#nth">nth</a>
		</div>
		<div>
			<a href="#only">only</a>
		</div>
		<div>
			<a href="#pad">pad</a>
		</div>
		<div>
			<a href="#partition">partition</a>
		</div>
		<div>
			<a href="#percentage">percentage</a>
		</div>
		<div>
			<a href="#pipe">pipe</a>
		</div>
		<div>
			<a href="#pipeInto">pipeInto</a>
		</div>
		<div>
			<a href="#pipeThrough">pipeThrough</a>
		</div>
		<div>
			<a href="#pluck">pluck</a>
		</div>
		<div>
			<a href="#pop">pop</a>
		</div>
		<div>
			<a href="#prepend">prepend</a>
		</div>
		<div>
			<a href="#pull">pull</a>
		</div>
		<div>
			<a href="#push">push</a>
		</div>
		<div>
			<a href="#put">put</a>
		</div>
		<div>
			<a href="#random">random</a>
		</div>
		<div>
			<a href="#range">range</a>
		</div>
		<div>
			<a href="#reduce">reduce</a>
		</div>
		<div>
			<a href="#reduceSpread">reduceSpread</a>
		</div>
		<div>
			<a href="#reject">reject</a>
		</div>
		<div>
			<a href="#replace">replace</a>
		</div>
		<div>
			<a href="#replaceRecursive">replaceRecursive</a>
		</div>
		<div>
			<a href="#reverse">reverse</a>
		</div>
		<div>
			<a href="#search">search</a>
		</div>
		<div>
			<a href="#select">select</a>
		</div>
		<div>
			<a href="#shift">shift</a>
		</div>
		<div>
			<a href="#shuffle">shuffle</a>
		</div>
		<div>
			<a href="#skip">skip</a>
		</div>
		<div>
			<a href="#skipUntil">skipUntil</a>
		</div>
	</div>
	<div style={{ flex: 1, minWidth: "200px", lineHeight: "1.6" }}>
		<div>
			<a href="#skipWhile">skipWhile</a>
		</div>
		<div>
			<a href="#slice">slice</a>
		</div>
		<div>
			<a href="#sliding">sliding</a>
		</div>
		<div>
			<a href="#sole">sole</a>
		</div>
		<div>
			<a href="#some">some</a>
		</div>
		<div>
			<a href="#sort">sort</a>
		</div>
		<div>
			<a href="#sortBy">sortBy</a>
		</div>
		<div>
			<a href="#sortByDesc">sortByDesc</a>
		</div>
		<div>
			<a href="#sortDesc">sortDesc</a>
		</div>
		<div>
			<a href="#sortKeys">sortKeys</a>
		</div>
		<div>
			<a href="#sortKeysDesc">sortKeysDesc</a>
		</div>
		<div>
			<a href="#sortKeysUsing">sortKeysUsing</a>
		</div>
		<div>
			<a href="#splice">splice</a>
		</div>
		<div>
			<a href="#split">split</a>
		</div>
		<div>
			<a href="#splitIn">splitIn</a>
		</div>
		<div>
			<a href="#sum">sum</a>
		</div>
		<div>
			<a href="#take">take</a>
		</div>
		<div>
			<a href="#takeUntil">takeUntil</a>
		</div>
		<div>
			<a href="#takeWhile">takeWhile</a>
		</div>
		<div>
			<a href="#tap">tap</a>
		</div>
		<div>
			<a href="#times">times</a>
		</div>
		<div>
			<a href="#toArray">toArray</a>
		</div>
		<div>
			<a href="#toJson">toJson</a>
		</div>
		<div>
			<a href="#transform">transform</a>
		</div>
		<div>
			<a href="#undot">undot</a>
		</div>
		<div>
			<a href="#union">union</a>
		</div>
		<div>
			<a href="#unique">unique</a>
		</div>
		<div>
			<a href="#uniqueStrict">uniqueStrict</a>
		</div>
		<div>
			<a href="#unless">unless</a>
		</div>
		<div>
			<a href="#unlessEmpty">unlessEmpty</a>
		</div>
		<div>
			<a href="#unlessNotEmpty">unlessNotEmpty</a>
		</div>
		<div>
			<a href="#unwrap">unwrap</a>
		</div>
		<div>
			<a href="#value">value</a>
		</div>
		<div>
			<a href="#values">values</a>
		</div>
		<div>
			<a href="#when">when</a>
		</div>
		<div>
			<a href="#whenEmpty">whenEmpty</a>
		</div>
		<div>
			<a href="#whenNotEmpty">whenNotEmpty</a>
		</div>
		<div>
			<a href="#where">where</a>
		</div>
		<div>
			<a href="#whereStrict">whereStrict</a>
		</div>
		<div>
			<a href="#whereBetween">whereBetween</a>
		</div>
		<div>
			<a href="#whereIn">whereIn</a>
		</div>
		<div>
			<a href="#whereInStrict">whereInStrict</a>
		</div>
		<div>
			<a href="#whereInstanceOf">whereInstanceOf</a>
		</div>
		<div>
			<a href="#whereNotBetween">whereNotBetween</a>
		</div>
		<div>
			<a href="#whereNotIn">whereNotIn</a>
		</div>
		<div>
			<a href="#whereNotInStrict">whereNotInStrict</a>
		</div>
		<div>
			<a href="#whereNotNull">whereNotNull</a>
		</div>
		<div>
			<a href="#whereNull">whereNull</a>
		</div>
		<div>
			<a href="#wrap">wrap</a>
		</div>
		<div>
			<a href="#zip">zip</a>
		</div>
	</div>
</div>

## Methods Listing

### after()

The `after` method returns the item after the given item. `null` is returned if the given item is not found or is the last item:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1,2,3,4,5])

    collection.after(3);

    // 4

    collection.after(5);

    // null
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([1,2,3,4,5])

    collection.after(3);

    // 4

    collection.after(5);

    // null
    ```

  </TabItem>
</Tabs>

This method searches for the given item using "loose" comparison, meaning a string containing an integer value will be considered equal to an integer of the same value. To use "strict" comparison, you may provide the `strict` argument to the method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([1,2,3,4,5]).after("4", true);

    // null
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collect([1,2,3,4,5]).after("4", true);

    // null
    ```

  </TabItem>
</Tabs>

Alternatively, you may provide your own closure to search for the first item that passes a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([2, 4, 6, 8]).after(function (item) {
      return item > 5;
    });

    // 8
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collect([2, 4, 6, 8]).after(function (item) {
      return item > 5;
    });

    // 8
    ```

  </TabItem>
</Tabs>

### all()

The `all` method returns the underlying array represented by the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([1, 2, 3]).all();
 
    // [1, 2, 3]
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collect([1, 2, 3]).all();
 
    // [1, 2, 3]
    ```

  </TabItem>
</Tabs>

### average()

Alias for the [avg](#avg) method.

### avg()

The `avg` method returns the average `value` of a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const average = collect([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).avg("foo");

    // 20

    const average  = collect([1, 1, 2, 4]).avg();

    // 2
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const average = collect([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).avg("foo");

    // 20

    const average  = collect([1, 1, 2, 4]).avg();

    // 2
    ```

  </TabItem>
</Tabs>

### before()

The `before` method is the opposite of the `after` method. It returns the item before the given item. `null` is returned if the given item is not found or is the first item:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1,2,3,4,5])

    collection.before(3);

    // 2

    collection.before(1);

    // null

    collection.before("4", true);

    // null

    collection.before(function (item) {
      return item > 5;
    });

    // 4
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([1,2,3,4,5])

    collection.before(3);

    // 2

    collection.before(1);

    // null

    collection.before("4", true);

    // null

    collection.before(function (item) {
      return item > 5;
    });

    // 4
    ```

  </TabItem>
</Tabs>

### chunk()

The `chunk` method breaks the collection into multiple, smaller collections of a given size:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 3, 4, 5, 6, 7])

    const chunks = collection.chunk(4);

    chunks.all();

    // [[1, 2, 3, 4], [5, 6, 7]]
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([1, 2, 3, 4, 5, 6, 7])

    const chunks = collection.chunk(4);

    chunks.all();

    // [[1, 2, 3, 4], [5, 6, 7]]
    ```

  </TabItem>
</Tabs>

### collect()

The `collect` method returns a new `Collection` instance with the items currently in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collectionA = collect([1, 2, 3]);

    const collectionB = collectionA.collect();

    collectionB.all();

    // [1, 2, 3]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collectionA = collect([1, 2, 3]);

    const collectionB = collectionA.collect();

    collectionB.all();

    // [1, 2, 3]
    ```

  </TabItem>
</Tabs>

### concat()

The concat method appends the given array or collection's values onto the end of another collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect(["Jhon Doe"])

    const concatenated = collection.concat(["Jane Doe"]).concat([
      "Jhonny Doe",
    ])

    concatenated.all();

    // ["Jhon Doe", "Jane Doe", "Jhonny Doe"]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect(["Jhon Doe"])

    const concatenated = collection.concat(["Jane Doe"]).concat([
      "Jhonny Doe",
    ])

    concatenated.all();

    // ["Jhon Doe", "Jane Doe", "Jhonny Doe"]
    ```

  </TabItem>
</Tabs>

### contains()

The `contains` method determines whether the collection contains a given item. You may pass a closure to the `contains` method to determine if an element exists in the collection matching a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 3, 4, 5]);

    collection.contains((item) => {
      return item > 5;
    });

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([1, 2, 3, 4, 5]);

    collection.contains((item) => {
      return item > 5;
    });

    // false
    ```

  </TabItem>
</Tabs>

Alternatively, you may pass a string to the `contains` method to determine whether the collection contains a given item value:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([{name: "Desk", price: 100}]);

    collection.contains("Desk")

    // true

    collection.contains("New York")

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{name: "Desk", price: 100}]);

    collection.contains("Desk")

    // true

    collection.contains("New York")

    // false
    ```

  </TabItem>
</Tabs>

You may also pass a key / value pair to the `contains` method, which will determine if the given pair exists in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      {product: "Desk", price: 200}
      {product: "Chair", price: 100}
    ]);

    collection.contains("product", "Bookcase");

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200}
      {product: "Chair", price: 100}
    ]);

    collection.contains("product", "Bookcase");

    // false
    ```

  </TabItem>
</Tabs>

The `contains` method uses "loose" comparisons when checking item values, meaning a string with an integer value will be considered equal to an integer of the same value. Use the [containsStrict](#containsStrict) method to filter using "strict" comparisons.

> For the inverse of `contains`, see the [doesntContain](#doesntContain) method.

### containsStrict()

This method has the same signature as the [contains](#contains) method; however, all values are compared using "strict" comparisons.

### count()

The `count` method returns the total number of items in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 3, 4]);

    collection.count();

    // 4
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([1, 2, 3, 4]);

    collection.count();

    // 4
    ```

  </TabItem>
</Tabs>

### countBy()

The `countBy` method counts the occurrences of values in the collection. By default, the method counts the occurrences of every element, allowing you to count certain "types" of elements in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 2, 2, 3]);

    const counted = collection.countBy();

    counted.all();

    // {1: 1, 2: 3, 3: 1}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([1, 2, 2, 2, 3]);

    const counted = collection.countBy();

    counted.all();

    // {1: 1, 2: 3, 3: 1}
    ```

  </TabItem>
</Tabs>

You may pass a closure to the `countBy` method to count all items by a custom value:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect(["alice@gmail.com", "bob@yahoo.com", "carlos@gmail.com",]);

    const counted = collection.countBy((item) => {
      return item.email.split("@")[1];
    });

    counted.all();

    // {gmail.com: 2, yahoo.com: 1}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect(["alice@gmail.com", "bob@yahoo.com", "carlos@gmail.com",]);

    const counted = collection.countBy((item) => {
      return item.email.split("@")[1];
    });

    counted.all();

    // {gmail.com: 2, yahoo.com: 1}
    ```

  </TabItem>
</Tabs>

### doesntContain()

The `doesntContain` method determines whether the collection does not contain a given item. You may pass a closure to the `doesntContain` method to determine if an element does not exist in the collection matching a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 3, 4, 5]);

    collection.doesntContain((item) => {
      return item < 5;
    });

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([1, 2, 3, 4, 5]);

    collection.doesntContain((item) => {
      return item < 5;
    });

    // false
    ```

  </TabItem>
</Tabs>

Alternatively, you may pass a string to the doesntContain method to determine whether the collection does not contain a given item value:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      {product: "Desk", price: 200}
    ]);

    collection.doesntContain("Table");

    // true

    collection.doesntContain("Desk");

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200}
    ]);

    collection.doesntContain("Table");

    // true

    collection.doesntContain("Desk");

    // false
    ```

  </TabItem>
</Tabs>

You may also pass a key / value pair to the `doesntContain` method, which will determine if the given pair does not exist in the collection:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      {product: "Desk", price: 200}
      {product: "Chair", price: 100}
    ]);

    collection.doesntContain("product", "Bookcase");

    // true
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200}
      {product: "Chair", price: 100}
    ]);

    collection.doesntContain("product", "Bookcase");

    // true
    ```

  </TabItem>
</Tabs>

### duplicates()

The `duplicates` method retrieves and returns duplicate values from the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect(["a", "b", "a", "c", "b"]);

    collection.duplicates();

    // {2: "a", 4: "b"}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect(["a", "b", "a", "c", "b"]);

    collection.duplicates();

    // {2: "a", 4: "b"}
    ```

  </TabItem>
</Tabs>

If the collection contains arrays or objects, you can pass the key of the attributes that you wish to check for duplicate values:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      { email: "abigail@example.com", position: "Developer" },
      { email: "james@example.com", position: "Designer" },
      { email: "victoria@example.com", position: "Developer" },
    ]);

    collection.duplicates("position");

    // {2: "Developer"}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      { email: "abigail@example.com", position: "Developer" },
      { email: "james@example.com", position: "Designer" },
      { email: "victoria@example.com", position: "Developer" },
    ]);

    collection.duplicates("position");

    // {2: "Developer"}
    ```

  </TabItem>  
</Tabs>

### each()

The `each` method iterates over the items in the collection and passes each item to a closure:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 3, 4]);

    collection.each((item) => {
      // ...
    });
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([1, 2, 3, 4]);

    collection.each((item) => {
      // ...
    });
    ```

  </TabItem>
</Tabs>

If you would like to stop iterating through the items, you may return `false` from your closure:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.each((item) => {
      if (/* condition */) {
        return false;
      }
    });
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collection.each((item) => {
      if (/* condition */) {
        return false;
      }
    });
    ```

  </TabItem>
</Tabs>

### isEvery()

The `isEvery` method may be used to verify that all elements of a collection pass a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([1, 2, 3, 4]).isEvery((item) => {
      return item > 2;
    });

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([1, 2, 3, 4]).isEvery((item) => {
      return item > 2;
    });

    // false
    ```

  </TabItem>
</Tabs>

If the collection is empty, the `isEvery` method will return true:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([])
    
    collection.isEvery((item) => {
      return item.foo > 2;
    });

    // true
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([])
    
    collection.isEvery((item) => {
      return item.foo > 2;
    });

    // true
    ```

  </TabItem>
</Tabs>

### except()

The `except` method returns all items in the collection except for those with the specified keys:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      {productId: 1, price: 100, discount: false},
    ]);

    const filtered = collection.except(["price", "discount"]);

    filtered.all();

    // {productId: 1}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {productId: 1, price: 100, discount: false},
    ]);

    const filtered = collection.except(["price", "discount"]);

    filtered.all();

    // {productId: 1}
    ```

  </TabItem>
</Tabs>

For the inverse of `except`, see the [only](#only) method.

### first()

The `first` method returns the first element in the collection that passes a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([1, 2, 3, 4]).first((item) => {
      return item > 2;
    });

    // 3
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([1, 2, 3, 4]).first((item) => {
      return item > 2;
    });

    // 3
    ```

  </TabItem>
</Tabs>

You may also call the `first` method with no arguments to get the first element in the collection. If the collection is empty, `null` is returned:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([1, 2, 3, 4]).first();

    // 1
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([1, 2, 3, 4]).first();

    // 1
    ```

  </TabItem>
</Tabs>

### firstOrFail()

The `firstOrFail` method is identical to the first method; however, if no result is found, `MongoloquentItemNotFoundException` exception will be thrown:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([1, 2, 3, 4]).first(item => {
      return item.foo > 5;
    });

    // MongoloquentItemNotFoundException
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([1, 2, 3, 4]).first(item => {
      return item.foo > 5;
    });

    // MongoloquentItemNotFoundException
    ```

  </TabItem>
</Tabs>

You may also call the `firstOrFail` method with no arguments to get the first element in the collection. If the collection is empty, an `MongoloquentItemNotFoundException` exception will be thrown:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect([]).first(item => {
      return item.foo > 5;
    });

    // MongoloquentItemNotFoundException
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([]).first(item => {
      return item.foo > 5;
    });

    // MongoloquentItemNotFoundException
    ```

  </TabItem>
</Tabs>

### firstWhere()

The `firstWhere` method returns the first element in the collection with the given key / value pair:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      {name: "Regena", age: null},
      {name: "Linda", age: 14},
      {name: "Diego", age: 23},
      {name: "Linda", age: 84},
    ]);

    collection.firstWhere("name", "Linda");

    // {name: "Linda", age: 14}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: "Regena", age: null},
      {name: "Linda", age: 14},
      {name: "Diego", age: 23},
      {name: "Linda", age: 84},
    ]);

    collection.firstWhere("name", "Linda");

    // {name: "Linda", age: 14}
    ```

  </TabItem>
</Tabs>

You may also call the `firstWhere` method with a comparison operator:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.firstWhere("age", ">=", 18);

    // {name: "Diego", age: 23}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collection.firstWhere("age", ">=", 18);

    // {name: "Diego", age: 23}
    ```

  </TabItem>
</Tabs>

Like the [where](#where) method, you may pass one argument to the `firstWhere` method. In this scenario, the `firstWhere` method will return the first item where the given item key's value is "truthy":

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.firstWhere("age");

    // {name: "Linda", age: 14}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collection.firstWhere("age");

    // {name: "Linda", age: 14}
    ```

  </TabItem>
</Tabs>

### forget()

The `forget` method removes an item from the collection by its key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([{name: "Ajat", framework: "Mongoloquent"}]);

    // Forget a single key
    collection.forget("name");

    // {framework: "Mongoloquent"}

    // Forget multiple keys
    collection.forget(["name", "framework"]);

    // {}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{name: "Ajat", framework: "Mongoloquent"}]);

    // Forget a single key
    collection.forget("name");

    // {framework: "Mongoloquent"}

    // Forget multiple keys
    collection.forget(["name", "framework"]);

    // {}
    ```

  </TabItem>
</Tabs>

> Unlike most other collection methods, `forget` does not return a new modified collection; it modifies and returns the collection it is called on.

### forPage()

The `forPage` method returns a new collection containing the items that would be present on a given page number. The method accepts the page number as its first argument and the number of items to show per page as its second argument:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);

    const chunk = collection.forPage(2, 3);

    chunk.all();

    // [4, 5, 6]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);

    const chunk = collection.forPage(2, 3);

    chunk.all();

    // [4, 5, 6]
    ```

  </TabItem>
</Tabs>

### get()

The `get` method returns the item at a given key. If the key does not exist, `null` is returned:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([{name: "ajat", framework: "mongoloquent"}])

    collection.get("name");

    // "ajat"
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{name: "ajat", framework: "mongoloquent"}])

    collection.get("name");

    // "ajat"
    ```

  </TabItem>
</Tabs>

You may optionally pass a default value as the second argument:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([{name: "ajat", framework: "mongoloquent"}])

    collection.get("age", 34);

    // 34
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{name: "ajat", framework: "mongoloquent"}])

    collection.get("age", 34);

    // 34
    ```

  </TabItem>
</Tabs>

You may even pass a callback as the method's default value. The result of the callback will be returned if the specified key does not exist:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([{name: "ajat", framework: "mongoloquent"}])

    collection.get("email", () => {
      return "ajat@example.com";
    });

    // ajat@example.com
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{name: "ajat", framework: "mongoloquent"}])

    collection.get("email", () => {
      return "ajat@example.com";
    });

    // ajat@example.com
    ```

  </TabItem>
</Tabs>

### groupBy()

The `groupBy` method groups the collection's items by a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect([
      { accountId: "account-x10", product: "Chair" },
      { accountId: "account-x10", product: "Bookcase" },
      { accountId: "account-x11", product: "Desk" },
    ]);

    const grouped = collection.groupBy("accountId");

    grouped.all();

    /*
    [
      {
        "account-x10": [
          {
            "accountId": "account-x10",
            "product": "Chair"
          },
          {
            "accountId": "account-x10",
            "product": "Bookcase"
          }
        ]
      },
      {
        "account-x11": [
          {
            "accountId": "account-x11",
            "product": "Desk"
          }
        ]
      }
    ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      { accountId: "account-x10", product: "Chair" },
      { accountId: "account-x10", product: "Bookcase" },
      { accountId: "account-x11", product: "Desk" },
    ]);

    const grouped = collection.groupBy("accountId");

    grouped.all();

    /*
    [
      {
        "account-x10": [
          {
            "accountId": "account-x10",
            "product": "Chair"
          },
          {
            "accountId": "account-x10",
            "product": "Bookcase"
          }
        ]
      },
      {
        "account-x11": [
          {
            "accountId": "account-x11",
            "product": "Desk"
          }
        ]
      }
    ]
    */
    ```

  </TabItem>
</Tabs>

Instead of passing a string `key`, you may pass a callback. The callback should return the value you wish to key the group by:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const grouped = collection.groupBy((item => {
      return item.accountId.substring(8);
    }));

    grouped.all();

    /*
    [
      {
        "x10": [
          {
            "accountId": "account-x10",
            "product": "Chair"
          },
          {
            "accountId": "account-x10",
            "product": "Bookcase"
          }
        ]
      },
      {
        "x11": [
          {
            "accountId": "account-x11",
            "product": "Desk"
          }
        ]
      }
    ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const grouped = collection.groupBy((item => {
      return item.accountId.substring(8);
    }));

    grouped.all();

    /*
    [
      {
        "x10": [
          {
            "accountId": "account-x10",
            "product": "Chair"
          },
          {
            "accountId": "account-x10",
            "product": "Bookcase"
          }
        ]
      },
      {
        "x11": [
          {
            "accountId": "account-x11",
            "product": "Desk"
          }
        ]
      }
    ]
    */
    ```

  </TabItem>
</Tabs>

### has()

The `has` method determines if a given key exists in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([{accountId: 1, product: "Desk", amount: 5}]);

    collection.has("product");

    // true

    collection.has(["product", "amount"]);

    // true

    collection.has("amount", "price");

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{accountId: 1, product: "Desk", amount: 5}]);

    collection.has("product");

    // true

    collection.has(["product", "amount"]);

    // true

    collection.has("amount", "price");

    // false
    ```

  </TabItem>
</Tabs>

### hasAny()

The `hasAny` method determines whether any of the given keys exist in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([{accountId: 1, product: "Desk", amount: 5}]);

    collection.hasAny(["product", "price"]);

    // true

    collection.hasAny(["name", "price"]);

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{accountId: 1, product: "Desk", amount: 5}]);

    collection.hasAny(["product", "price"]);

    // true

    collection.hasAny(["name", "price"]);

    // false
    ```

  </TabItem>
</Tabs>

### implode()

The `implode` method joins items in a collection. Its arguments depend on the type of items in the collection. If the collection contains arrays or objects, you should pass the key of the attributes you wish to join, and the "glue" string you wish to place between the values:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {accountId: 1, product: "Desk"},
      {accountId: 2, product: "Chair"},
    ]);

    collection.implode("product", ", ");

    // "Desk, Chair"
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {accountId: 1, product: "Desk"},
      {accountId: 2, product: "Chair"},
    ]);

    collection.implode("product", ", ");

    // "Desk, Chair"
    ```

  </TabItem>
</Tabs>

You may pass a closure to the `implode` method if you would like to format the values being imploded:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.implode((item) => {
      return item.product.toUpperCase();
    }, ", ");

    // "DESK, CHAIR"
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collection.implode((item) => {
      return item.product.toUpperCase();
    }, ", ");

    // "DESK, CHAIR"
    ```

  </TabItem>
</Tabs>

### isEmpty()

The `isEmpty` method returns `true` if the collection is empty; otherwise, `false` is returned:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([]).isEmpty();

    // true
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([]).isEmpty();

    // true
    ```

  </TabItem>
</Tabs>

### isNotEmpty()

The `isNotEmpty` method returns `true` if the collection is not empty; otherwise, `false` is returned:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([]).isNotEmpty();

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([]).isNotEmpty();

    // false
    ```

  </TabItem>
</Tabs>

### keyBy()

The `keyBy` method keys the collection by the given key. If multiple items have the same key, only the last one will appear in the new collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {productId: "prod-100", product: "Desk"},
      {productId: "prod-200", product: "Chair"},
    ]);

    const keyed = collection.keyBy("productId");

    keyed.all();

    /*
      [
        {
          "prod-100": {
            "productId": "prod-100",
            "product": "Desk"
          }
        },
        {
          "prod-200": {
            "productId": "prod-200",
            "product": "Chair"
          }
        }
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {productId: "prod-100", product: "Desk"},
      {productId: "prod-200", product: "Chair"},
    ]);

    const keyed = collection.keyBy("productId");

    keyed.all();

    /*
      [
        {
          "prod-100": {
            "productId": "prod-100",
            "product": "Desk"
          }
        },
        {
          "prod-200": {
            "productId": "prod-200",
            "product": "Chair"
          }
        }
      ]
    */
    ```

  </TabItem>
</Tabs>

You may also pass a callback to the method. The callback should return the value to key the collection by:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const keyed = collection.keyBy((item => {
      return item.productId.toUpperCase();
    }));

    keyed.all();

    /*
      [
        {
          "PROD-100": {
            "productId": "prod-100",
            "product": "Desk"
          }
        },
        {
          "PROD-200": {
            "productId": "prod-200",
            "product": "Chair"
          }
        }
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const keyed = collection.keyBy((item => {
      return item.productId.toUpperCase();
    }));

    keyed.all();

    /*
      [
        {
          "PROD-100": {
            "productId": "prod-100",
            "product": "Desk"
          }
        },
        {
          "PROD-200": {
            "productId": "prod-200",
            "product": "Chair"
          }
        }
      ]
    */
    ```

  </TabItem>
</Tabs>

### last()

The `last` method returns the last element in the collection that passes a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]).last((item) => {
      return item.foo < 3;
    });

    // {foo: 2}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]).last((item) => {
      return item.foo < 3;
    });

    // {foo: 2}
    ```

  </TabItem>
</Tabs>

You may also call the `last` method with no arguments to get the last element in the collection. If the collection is empty, `null` is returned:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]).last();

    // {foo: 4}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]).last();

    // {foo: 4}
    ```

  </TabItem>
</Tabs>

### make()

The static make method creates a new collection instance. See the [Creating Collections](#creating-collections) section.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import {Collection} from "mongoloquent";

    const collection = Collection.make<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]);
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    import {Collection} from "mongoloquent";

    const collection = Collection.make([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]);
    ```

  </TabItem>
</Tabs>

The `mapToGroups` method groups the collection's items by the given closure. The closure should return an associative array containing a single key / value pair, thus forming a new collection of grouped values:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "John Doe", department: "Sales"},
      {name: "Jane Doe", department: "Sales"},
      {name: "Jhonny Smith", department: "Marketing"},
    ]);

    const grouped = collection.mapToGroups((item) => {
      return {
        [item.department]: item.name,
      };
    });

    grouped.all();

    /*
      [
        [
          "John Doe",
          "Jane Doe"
        ],
        [
          "Jhonny Smith"
        ]
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: "John Doe", department: "Sales"},
      {name: "Jane Doe", department: "Sales"},
      {name: "Jhonny Smith", department: "Marketing"},
    ]);

    const grouped = collection.mapToGroups((item) => {
      return {
        [item.department]: item.name,
      };
    });

    grouped.all();

    /*
      [
        [
          "John Doe",
          "Jane Doe"
        ],
        [
          "Jhonny Smith"
        ]
      ]
    */
    ```

  </TabItem>
</Tabs>

### mapWithKeys()

The `mapWithKeys` method iterates through the collection and passes each value to the given callback. The callback should return an associative array containing a single key / value pair:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {
        name: "Jhon",
        department: "Sales",
        email: "jhon@example.com"
      },
      {
        name: "Jane",
        department: "Marketing",
        email: "jane@example.com"
      }
    ]);

    const keyed = collection.mapWithKeys((item) => {
      return {
        [item.email]: item.name,
      };
    });

    keyed.all();

    /*
      {
        'john@example.com' => 'John',
        'jane@example.com' => 'Jane',
      }
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {
        name: "Jhon",
        department: "Sales",
        email: "jhon@example.com"
      },
      {
        name: "Jane",
        department: "Marketing",
        email: "jane@example.com"
      }
    ]);

    const keyed = collection.mapWithKeys((item) => {
      return {
        [item.email]: item.name,
      };
    });

    keyed.all();

    /*
      {
        'john@example.com' => 'John',
        'jane@example.com' => 'Jane',
      }
    */
    ```

  </TabItem>
</Tabs>

### max()

The `max` method returns the maximum value of a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const max = collect<IData>([
      {foo: 10},
      {foo: 20},
    ]).max("foo");

    // 20
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const max = collect([
      {foo: 10},
      {foo: 20},
    ]).max("foo");

    // 20
    ```

  </TabItem>
</Tabs>

### median()

The `median` method returns the [median value](https://en.wikipedia.org/wiki/Median) of a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const median = collect<IData>([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).median("foo");

    // 15

    const median = collect<IData>([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]).median("foo");

    // 1.5
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const median = collect<IData>([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).median("foo");

    // 15

    const median = collect<IData>([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]).median("foo");

    // 1.5
    ```

  </TabItem>
</Tabs>

### min()

The `min` method returns the minimum value of a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const min = collect<IData>([
      {foo: 10},
      {foo: 20},
    ]).min("foo");

    // 10

    const min = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]).min("foo");

    // 1
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const min = collect([
      {foo: 10},
      {foo: 20},
    ]).min("foo");

    // 10

    const min = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]).min("foo");

    // 1
    ```

  </TabItem>
</Tabs>

### multiply()

The `multiply` method creates the specified number of copies of all items in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const users = collect<IData>([
      {name: "User #1", email: "user1@example.com"},
      {name: "User #2", email: "user2@example.com"}
    ]).multiply(3);

    /*
      [
        {name: "User #1", email: "user1@example.com"},
        {name: "User #2", email: "user2@example.com"},
        {name: "User #1", email: "user1@example.com"},
        {name: "User #2", email: "user2@example.com"},
        {name: "User #1", email: "user1@example.com"},
        {name: "User #2", email: "user2@example.com"}
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const users = collect<IData>([
      {name: "User #1", email: "user1@example.com"},
      {name: "User #2", email: "user2@example.com"}
    ]).multiply(3);

    /*
      [
        {name: "User #1", email: "user1@example.com"},
        {name: "User #2", email: "user2@example.com"},
        {name: "User #1", email: "user1@example.com"},
        {name: "User #2", email: "user2@example.com"},
        {name: "User #1", email: "user1@example.com"},
        {name: "User #2", email: "user2@example.com"}
      ]
    */
    ```

  </TabItem>
</Tabs>

### nth()

The `nth` method creates a new collection consisting of every n-th element:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: "a"},
      {foo: "b"},
      {foo: "c"},
      {foo: "d"},
      {foo: "e"},
      {foo: "f"},
    ]);

    collection.nth(4);

    /*
      [
        {
          "foo": "a"
        },
        {
          "foo": "e"
        }
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: "a"},
      {foo: "b"},
      {foo: "c"},
      {foo: "d"},
      {foo: "e"},
      {foo: "f"},
    ]);

    collection.nth(4);

    /*
      [
        {
          "foo": "a"
        },
        {
          "foo": "e"
        }
      ]
    */
    ```

  </TabItem>
</Tabs>

You may optionally pass a starting offset as the second argument:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.nth(4, 1);

    /*
      [
        {
          "foo": "b"
        },
        {
          "foo": "f"
        }
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collection.nth(4, 1);

    /*
      [
        {
          "foo": "b"
        },
        {
          "foo": "f"
        }
      ]
    */
    ```

  </TabItem>
</Tabs>

### only()

The `only` method returns the items in the collection with the specified keys:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {
        productId: 1,
        name: "Desk",
        price: 100,
        discount: false,
      },
    ]);

    const filtered = collection.only(["productId", "name"]);

    filtered.all();

    // {productId: 1, name: "Desk"}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {
        productId: 1,
        name: "Desk",
        price: 100,
        discount: false,
      },
    ]);

    const filtered = collection.only(["productId", "name"]);

    filtered.all();

    // {productId: 1, name: "Desk"}
    ```

  </TabItem>
</Tabs>

For the inverse of `only`, see the [except](#except) method.

### pluck()

The pluck method retrieves all of the values for a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {productId: 1, name: "Desk"},
      {productId: 2, name: "Chair"},
    ]);

    const plucked = collection.pluck("name");

    plucked.all();

    // ["Desk", "Chair"]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {productId: 1, name: "Desk"},
      {productId: 2, name: "Chair"},
    ]);

    const plucked = collection.pluck("name");

    plucked.all();

    // ["Desk", "Chair"]
    ```

  </TabItem>
</Tabs>

You may also pass multiple keys to the `pluck` method.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {productId: 1, name: "Desk"},
      {productId: 2, name: "Chair"},
    ]);

    const plucked = collection.pluck("name", "productId");

    plucked.all();

    /*
      {
        "mame": "Desk",
        "productId": 1
      },
      {
        "mame": "Chair",
        "productId": 2
      }
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {productId: 1, name: "Desk"},
      {productId: 2, name: "Chair"},
    ]);

    const plucked = collection.pluck("name", "productId");

    plucked.all();

    /*
      {
        "mame": "Desk",
        "productId": 1
      },
      {
        "mame": "Chair",
        "productId": 2
      }
    */
    ```

  </TabItem>
</Tabs>

### pull()

The pull `method` removes and returns an item from the collection by its key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([{productId: "prod-100", name: "Desk"}]);

    collection.pull("name");

    // Desk

    collection.all();

    // {productId: "prod-100"}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{productId: "prod-100", name: "Desk"}]);

    collection.pull("name");

    // Desk

    collection.all();

    // {productId: "prod-100"}
    ```

  </TabItem>
</Tabs>

### random()

The random `method` returns a random item from the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.random();

    // {foo: 4} - (retrived randomly)
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.random();

    // {foo: 4} - (retrived randomly)
    ```

  </TabItem>
</Tabs>

You may pass an integer to `random` to specify how many items you would like to randomly retrieve. A collection of items is always returned when explicitly passing the number of items you wish to receive:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const random = collection.random(3)

    // [{foo: 2}, {foo: 4}, {foo: 5}] - (retrived randomly)
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const random = collection.random(3)

    // [{foo: 2}, {foo: 4}, {foo: 5}] - (retrived randomly)
    ```

  </TabItem>
</Tabs>

If the collection instance has fewer items than requested, the random method will throw an `MongoloquentInvalidArgumentException`.

### range()

The `range` method returns a collection containing integers between the specified range:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
    ]).range("foo", [3, 6]);

    collection.all();

    // [{foo: 3}, {foo: 4}, {foo: 5}, {foo: 6}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
    ]).range("foo", [3, 6]);

    collection.all();

    // [{foo: 3}, {foo: 4}, {foo: 5}, {foo: 6}]
    ```

  </TabItem>
</Tabs>

### select()

The select method selects the given keys from the collection, similar to an SQL `SELECT` statement:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const users = collect<IData>([
      {name: "Ajat Darojat", role: "Developer", status: "active"},
      {name: "Udin", role: "Developer", status: "active"},
    ]);

    users.select(["name", "role"]).all();

    /*
      [
        {name: "Ajat Darojat", role: "Developer"},
        {name: "Udin", role: "Developer"},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const users = collect<IData>([
      {name: "Ajat Darojat", role: "Developer", status: "active"},
      {name: "Udin", role: "Developer", status: "active"},
    ]);

    users.select(["name", "role"]).all();

    /*
      [
        {name: "Ajat Darojat", role: "Developer"},
        {name: "Udin", role: "Developer"},
      ]
    */
    ```

  </TabItem>
</Tabs>

### shuffle()

The `shuffle` method randomly shuffles the items in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const shuffled = collection.shuffle();

    shuffled.all();

    // [{foo: 4}, {foo: 1}, {foo: 3}, {foo: 5}, {foo: 2}] - (retrived randomly)
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const shuffled = collection.shuffle();

    shuffled.all();

    // [{foo: 4}, {foo: 1}, {foo: 3}, {foo: 5}, {foo: 2}] - (retrived randomly)
    ```

  </TabItem>
</Tabs>

### skip()

The `skip` method returns a new collection, with the given number of elements removed from the beginning of the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
      {foo: 8},
      {foo: 9},
      {foo: 10},
    ]);

    const skipped = collection.skip(4);

    skipped.all();

    // [{foo: 5}, {foo: 6}, {foo: 7}, {foo: 8}, {foo: 9}, {foo: 10}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
     const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
      {foo: 8},
      {foo: 9},
      {foo: 10},
    ]);

    const skipped = collection.skip(4);

    skipped.all();

    // [{foo: 5}, {foo: 6}, {foo: 7}, {foo: 8}, {foo: 9}, {foo: 10}]
    ```

  </TabItem>
</Tabs>

### skipUntil()

The `skipUntil` method skips over items from the collection while the given callback returns `false`. Once the callback returns `true` all of the remaining items in the collection will be returned as a new collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.skipUntil((item) => {
      return item.foo >= 3;
    });

    subset.all();

    // [{foo: 3}, {foo: 4}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.skipUntil((item) => {
      return item.foo >= 3;
    });

    subset.all();

    // [{foo: 3}, {foo: 4}]
    ```

  </TabItem>
</Tabs>

> If the given value is not found or the callback never returns `true`, the `skipUntil` method will return an empty collection.

### skipWhile()

The `skipWhile` method skips over items from the collection while the given callback returns `true`. Once the callback returns `false` all of the remaining items in the collection will be returned as a new collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.skipWhile((item) => {
      return item.foo <= 3;
    });

    subset.all();

    // [{foo: 4}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.skipWhile((item) => {
      return item.foo <= 3;
    });

    subset.all();

    // [{foo: 4}]
    ```

  </TabItem>
</Tabs>

> If the callback never returns `false`, the `skipWhile` method will return an empty collection.

### sliding()

The sliding method returns a new collection of chunks representing a "sliding window" view of the items in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const chunks = collection.sliding(2);

    chunks.all();

    /*
      [
        [{foo: 1}, {foo: 2}],
        [{foo: 2}, {foo: 3}],
        [{foo: 3}, {foo: 4}],
        [{foo: 4}, {foo: 5}],
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const chunks = collection.sliding(2);

    chunks.all();

    /*
      [
        [{foo: 1}, {foo: 2}],
        [{foo: 2}, {foo: 3}],
        [{foo: 3}, {foo: 4}],
        [{foo: 4}, {foo: 5}],
      ]
    */
    ```

  </TabItem>
</Tabs>

You may optionally pass a second "step" value, which determines the distance between the first item of every chunk:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const chunks = collection.sliding(3, 2);

    chunks.all();

    /*
      [
        [{foo: 1}, {foo: 2}, {foo: 3}],
        [{foo: 3}, {foo: 4}, {foo: 5}],
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const chunks = collection.sliding(3, 2);

    chunks.all();

    /*
      [
        [{foo: 1}, {foo: 2}, {foo: 3}],
        [{foo: 3}, {foo: 4}, {foo: 5}],
      ]
    */
    ```

  </TabItem>
</Tabs>

### sole()

The `sole` method returns the first element in the collection that passes a given truth test, but only if the truth test matches exactly one element:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]).sole((item) => {
      return item.foo === 2;
    });

    // {foo: 2}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]).sole((item) => {
      return item.foo === 2;
    });

    // {foo: 2}
    ```

  </TabItem>
</Tabs>

You may also pass a key / value pair to the `sole` method, which will return the first element in the collection that matches the given pair, but only if it exactly one element matches:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
    ])

    collection.sole({product: "Chair"});

    // {product: "Chair", price: 100}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
    ])

    collection.sole({product: "Chair"});

    // {product: "Chair", price: 100}
    ```

  </TabItem>
</Tabs>

If there are no elements in the collection that should be returned by the `sole` method, an `MongoloquentItemNotFoundException` exception will be thrown.

### sortBy()

The `sortBy` method sorts the collection by the given key. The sorted collection keeps the original array keys, so in the following example we will use the `values` method to reset the keys to consecutively numbered indexes:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "Desk", price: 200},
      {name: "Chair", price: 100},
    ]);

    const sorted = collection.sortBy("price")

    sorted.all();

    /*
      [
        {name: "Chair", price: 100},
        {name: "Desk", price: 200},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: "Desk", price: 200},
      {name: "Chair", price: 100},
    ]);

    const sorted = collection.sortBy("price")

    sorted.all();

    /*
      [
        {name: "Chair", price: 100},
        {name: "Desk", price: 200},
      ]
    */
    ```

  </TabItem>
</Tabs>

The sortBy method accepts `sort flags` as its second argument:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const colletion = collect<IData>([
      {title: "Item 1"},
      {title: "Item 12"},
      {title: "Item 3"},
    ]);

    const sorted = collection.sortBy("title", "asc");

    sorted.all();

    /*
      [
        {title: "Item 1"},
        {title: "Item 12"},
        {title: "Item 3"},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const colletion = collect<IData>([
      {title: "Item 1"},
      {title: "Item 12"},
      {title: "Item 3"},
    ]);

    const sorted = collection.sortBy("title", "asc");

    sorted.all();

    /*
      [
        {title: "Item 1"},
        {title: "Item 12"},
        {title: "Item 3"},
      ]
    */
    ```

  </TabItem>
</Tabs>

### sortByDesc()

This method has the same signature as the [sortBy](#sortby) method, but will sort the collection in the opposite order.

### sortDesc()

This method will sort the collection in the opposite order as the `sort` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 5},
      {foo: 3},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]);

    const sorted = collection.sortDesc();

    sorted.all();

    /*
      [
        {foo: 5},
        {foo: 4},
        {foo: 3},
        {foo: 2},
        {foo: 1},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect<IData>([
      {foo: 5},
      {foo: 3},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]);

    const sorted = collection.sortDesc();

    sorted.all();

    /*
      [
        {foo: 5},
        {foo: 4},
        {foo: 3},
        {foo: 2},
        {foo: 1},
      ]
    */
    ```

  </TabItem>
</Tabs>

### split()

The `split` method breaks a collection into the given number of groups:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const split = collection.split(3);

    split.all();

    /*
      [
        [
          {foo: 1},
          {foo: 2}
        ],
        [
          {foo: 3},
          {foo: 4}
        ],
        [
          {foo: 5}
        ]
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const split = collection.split(3);

    split.all();

    /*
      [
        [
          {foo: 1},
          {foo: 2}
        ],
        [
          {foo: 3},
          {foo: 4}
        ],
        [
          {foo: 5}
        ]
      ]
    */
    ```

  </TabItem>
</Tabs>

### splitIn()

The `splitIn` method breaks a collection into the given number of groups, filling non-terminal groups completely before allocating the remainder to the final group:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
      {foo: 8},
      {foo: 9},
      {foo: 10},
    ]);

    const split = collection.splitIn(3);

    split.all();

    /*
      [
        [
          {foo: 1},
          {foo: 2},
          {foo: 3}
        ],
        [
          {foo: 4},
          {foo: 5},
          {foo: 6}
        ],
        [
          {foo: 7},
          {foo: 8},
          {foo: 9},
          {foo: 10}
        ]
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
      {foo: 8},
      {foo: 9},
      {foo: 10},
    ]);

    const split = collection.splitIn(3);

    split.all();

    /*
      [
        [
          {foo: 1},
          {foo: 2},
          {foo: 3}
        ],
        [
          {foo: 4},
          {foo: 5},
          {foo: 6}
        ],
        [
          {foo: 7},
          {foo: 8},
          {foo: 9},
          {foo: 10}
        ]
      ]
    */
    ```

  </TabItem>
</Tabs>

### sum()

The `sum` method returns the sum of all items in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]).sum("foo");

    // 15
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]).sum("foo");

    // 15
    ```

  </TabItem>
</Tabs>

If the collection contains nested arrays or objects, you should pass a key that will be used to determine which values to sum:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {'name': 'JavaScript: The Good Parts', 'pages': 176},
      {'name': 'JavaScript: The Definitive Guide', 'pages': 1096},
    ]);

    collection.sum('pages');

    // 1272
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {'name': 'JavaScript: The Good Parts', 'pages': 176},
      {'name': 'JavaScript: The Definitive Guide', 'pages': 1096},
    ]);

    collection.sum('pages');

    // 1272
    ```

  </TabItem>
</Tabs>

In addition, you may pass your own closure to determine which values of the collection to sum:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "Chair", colors: ["Black"]},
      {name: "Desk", colors: ["Black", "Mahogany"]},
      {name: "Bookcase", colors: ["Red", "Beige", "Brown"]},
    ]);

    collection.sum((item) => {
      return item.colors.length;
    });

    // 6
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript

    const collection = collect([
      {name: "Chair", colors: ["Black"]},
      {name: "Desk", colors: ["Black", "Mahogany"]},
      {name: "Bookcase", colors: ["Red", "Beige", "Brown"]},
    ]);

    collection.sum((item) => {
      return item.colors.length;
    });

    // 6
    ```

  </TabItem>
</Tabs>

### take()

The `take` method returns a new collection with the specified number of items:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 0}
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const taken = collection.take(3);

    taken.all();

    // [{foo: 0}, {foo: 1}, {foo: 2}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 0}
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const taken = collection.take(3);

    taken.all();

    // [{foo: 0}, {foo: 1}, {foo: 2}]
    ```

  </TabItem>
</Tabs>

You may also pass a negative integer to take the specified number of items from the end of the collection:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 0}
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const taken = collection.take(-2);

    taken.all();

    // [{foo: 4}, {foo: 5}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 0}
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const taken = collection.take(-2);

    taken.all();

    // [{foo: 4}, {foo: 5}]
    ```

  </TabItem>
</Tabs>

### takeUntil()

The `takeUntil` method returns items in the collection until the given callback returns `true`:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.takeUntil((item) => {
      return item.foo >= 3;
    });

    subset.all();

    // [{foo: 1}, {foo: 2}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.takeUntil((item) => {
      return item.foo >= 3;
    });

    subset.all();

    // [{foo: 1}, {foo: 2}]
    ```

  </TabItem>
</Tabs>

You may also pass a simple value to the `takeUntil` method to get the items until the given value is found:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.takeUntil(3);

    subset.all();

    // [{foo: 1}, {foo: 2}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.takeUntil(3);

    subset.all();

    // [{foo: 1}, {foo: 2}]
    ```

  </TabItem>
</Tabs>

> If the given value is not found or the callback never returns `true`, the `takeUntil` method will return all items in the collection.

### takeWhile()

The `takeWhile` method returns items in the collection until the given callback returns `false`:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.takeWhile((item) => {
      return item.foo < 3;
    });

    subset.all();

    // [{foo: 1}, {foo: 2}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    const subset = collection.takeWhile((item) => {
      return item.foo < 3;
    });

    subset.all();

    // [{foo: 1}, {foo: 2}]
    ```

  </TabItem>
</Tabs>

> If the callback never returns `false`, the `takeWhile` method will return all items in the collection.

### transform()

The `transform` method iterates over the collection and calls the given callback with each item in the collection. The items in the collection will be replaced by the values returned by the callback:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const transformed = collection.transform((item) => {
      return item.foo * 2;
    });

    transformed.all();

    // [2, 4, 6, 8, 10]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    const transformed = collection.transform((item) => {
      return item.foo * 2;
    });

    transformed.all();

    // [2, 4, 6, 8, 10]
    ```

  </TabItem>  
</Tabs>

The `unique` method returns all of the unique items in the collection. The returned collection keeps the original array keys, so in the following example we will use the [values](#values) method to reset the keys to consecutively numbered indexes:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 2},
    ]);

    const unique = collection.unique("foo");

    unique.all();

    // [{foo: 1}, {foo: 2}, {foo: 3}, {foo: 4}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 2},
    ]);

    const unique = collection.unique("foo");

    unique.all();

    // [{foo: 1}, {foo: 2}, {foo: 3}, {foo: 4}]
    ```

  </TabItem>
</Tabs>

When dealing with nested arrays or objects, you may specify the key used to determine uniqueness:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: 'iPhone 6', brand: 'Apple', type: 'phone'},
      {name: 'iPhone 5', brand: 'Apple', type: 'phone'},
      {name: 'Apple Watch', brand: 'Apple', type: 'watch'},
      {name: 'Galaxy S6', brand: 'Samsung', type: 'phone'},
      {name: 'Galaxy Gear', brand: 'Samsung', type: 'watch'}
    ]);

    const unique = collection.unique('brand');

    unique.all();

    /*
      [
        {name: 'iPhone 6', brand: 'Apple', type: 'phone'},
        {name: 'Galaxy S6', brand: 'Samsung', type: 'phone'}
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: 'iPhone 6', brand: 'Apple', type: 'phone'},
      {name: 'iPhone 5', brand: 'Apple', type: 'phone'},
      {name: 'Apple Watch', brand: 'Apple', type: 'watch'},
      {name: 'Galaxy S6', brand: 'Samsung', type: 'phone'},
      {name: 'Galaxy Gear', brand: 'Samsung', type: 'watch'}
    ]);

    const unique = collection.unique('brand');

    unique.all();

    /*
      [
        {name: 'iPhone 6', brand: 'Apple', type: 'phone'},
        {name: 'Galaxy S6', brand: 'Samsung', type: 'phone'}
      ]
    */
    ```

  </TabItem>
</Tabs>

Finally, you may also pass your own closure to the `unique` method to specify which value should determine an item's uniqueness:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const unique = collection.unique(function (item) {
      return item.brand + item.type;
    });

    unique.all();

    /*
      [
        {name: 'iPhone 6', brand: 'Apple', type: 'phone'},
        {name: 'Apple Watch', brand: 'Apple', type: 'watch'},
        {name: 'Galaxy S6', brand: 'Samsung', type: 'phone'},
        {name: 'Galaxy Gear', brand: 'Samsung', type: 'watch'}
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const unique = collection.unique(function (item) {
      return item.brand + item.type;
    });

    unique.all();

    /*
      [
        {name: 'iPhone 6', brand: 'Apple', type: 'phone'},
        {name: 'Apple Watch', brand: 'Apple', type: 'watch'},
        {name: 'Galaxy S6', brand: 'Samsung', type: 'phone'},
        {name: 'Galaxy Gear', brand: 'Samsung', type: 'watch'}
      ]
    */
    ```

  </TabItem>
</Tabs>

### value()

The `value` method retrieves a given value from the first element of the collection:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200}, 
      {product: "Speaker", price: 400},
    ]);

    const value = collection.value("pice");

    // 200
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200}, 
      {product: "Speaker", price: 400},
    ]);

    const value = collection.value("pice");

    // 200
    ```

  </TabItem>
</Tabs>

### where()

The `where` method filters the collection by a given key / value pair:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
      {product: "Bookcase", price: 150},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.where("price", 100);

    filtered.all();

    /*
      [
        {product: "Chair", price: 100},
        {product: "Door", price: 100},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
      {product: "Bookcase", price: 150},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.where("price", 100);

    filtered.all();

    /*
      [
        {product: "Chair", price: 100},
        {product: "Door", price: 100},
      ]
    */
    ```

  </TabItem>
</Tabs>

The `where` method uses "loose" comparisons when checking item values, meaning a string with an integer value will be considered equal to an integer of the same value.

Optionally, you may pass a comparison operator as the second parameter. Supported operators are: 'eq', 'ne', 'gt', 'lt', 'gte', 'lte', 'in', 'nin', 'regex':

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "Jim", deleted_at: "2019-01-01 00:00:00"},
      {name: "Saly", deleted_at: "2019-01-02 00:00:00"},
      {name: "Sue", deleted_at: null},
    ]);

    const filtered = collection.where("deleted_at", "ne", null);

    filtered.all();

    /*
      [
        {name: "Jim", deleted_at: "2019-01-01 00:00:00"},
        {name: "Saly", deleted_at: "2019-01-02 00:00:00"},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: "Jim", deleted_at: "2019-01-01 00:00:00"},
      {name: "Saly", deleted_at: "2019-01-02 00:00:00"},
      {name: "Sue", deleted_at: null},
    ]);

    const filtered = collection.where("deleted_at", "ne", null);

    filtered.all();

    /*
      [
        {name: "Jim", deleted_at: "2019-01-01 00:00:00"},
        {name: "Saly", deleted_at: "2019-01-02 00:00:00"},
      ]
    */
    ```

  </TabItem>
</Tabs>

### whereBetween()

The `whereBetween` method filters the collection by determining if a specified item value is within a given range:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200},
      {product: "Chair", price: 80},
      {product: "Bookcase", price: 150},
      {product: "Pencil", price: 30},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereBetween("price", [100, 200]);

    filtered.all();

    /*
      [
        {product: "Desk", price: 200},
        {product: "Bookcase", price: 150},
        {product: "Door", price: 100},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200},
      {product: "Chair", price: 80},
      {product: "Bookcase", price: 150},
      {product: "Pencil", price: 30},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereBetween("price", [100, 200]);

    filtered.all();

    /*
      [
        {product: "Desk", price: 200},
        {product: "Bookcase", price: 150},
        {product: "Door", price: 100},
      ]
    */
    ```

  </TabItem>
</Tabs>

### whereIn()

The `whereIn` method removes elements from the collection that do not have a specified item value that is contained within the given array:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
      {product: "Bookcase", price: 150},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereIn("price", [150, 200]);

    filtered.all();

    /*
      [
        {product: "Desk", price: 200},
        {product: "Bookcase", price: 150},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
      {product: "Bookcase", price: 150},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereIn("price", [150, 200]);

    filtered.all();

    /*
      [
        {product: "Desk", price: 200},
        {product: "Bookcase", price: 150},
      ]
    */
    ```

  </TabItem>
</Tabs>

### whereNotBetween()

The `whereNotBetween` method filters the collection by determining if a specified item value is outside of a given range:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200},
      {product: "Chair", price: 80},
      {product: "Bookcase", price: 150},
      {product: "Pencil", price: 30},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereNotBetween("price", [100, 200]);

    filtered.all();

    /*
      [
        {product: "Chair", price: 80},
        {product: "Pencil", price: 30},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200},
      {product: "Chair", price: 80},
      {product: "Bookcase", price: 150},
      {product: "Pencil", price: 30},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereNotBetween("price", [100, 200]);

    filtered.all();

    /*
      [
        {product: "Chair", price: 80},
        {product: "Pencil", price: 30},
      ]
    */
    ```

  </TabItem>
</Tabs>

### whereNotIn()

The `whereNotIn` method removes elements from the collection that have a specified item value that is contained within the given array:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
      {product: "Bookcase", price: 150},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereNotIn("price", [150, 200]);

    filtered.all();

    /*
      [
        {product: "Chair", price: 100},
        {product: "Door", price: 100},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {product: "Desk", price: 200},
      {product: "Chair", price: 100},
      {product: "Bookcase", price: 150},
      {product: "Door", price: 100},
    ]);

    const filtered = collection.whereNotIn("price", [150, 200]);

    filtered.all();

    /*
      [
        {product: "Chair", price: 100},
        {product: "Door", price: 100},
      ]
    */
    ```

  </TabItem>
</Tabs>

### whereNotNull()

The `whereNotNull` method returns items from the collection where the given key is not null:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "Desk"},
      {name: null},
      {name: "Bookcase"},
    ]);

    const filtered = collection.whereNotNull("name");

    filtered.all();

    /*
      [
        {name: "Desk"},
        {name: "Bookcase"},
      ]
    */
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript

    const collection = collect([
      {name: "Desk"},
      {name: null},
      {name: "Bookcase"},
    ]);
    ```

  </TabItem>
</Tabs>

### whereNull()

The `whereNull` method returns items from the collection where the given key is null:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "Desk"},
      {name: null},
      {name: "Bookcase"},
    ]);

    const filtered = collection.whereNull("name");

    filtered.all();

    // [{name: null}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: "Desk"},
      {name: null},
      {name: "Bookcase"},
    ]);

    const filtered = collection.whereNull("name");

    filtered.all();

    // [{name: null}]
    ```

  </TabItem>
</Tabs>

## Higher Order Messages

## Lazy Collections

### Introduction

### Creating Lazy Collections

### The Enumerable Contract

### Lazy Collection Methods

```

```

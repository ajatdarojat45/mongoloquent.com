---
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Sponsor from "./sponsor.mdx";

# Collections

## Introduction

The `Collection` class provides a fluent, convenient wrapper for working with arrays of data. For example, check out the following code. We'll use the collect helper to create a new collection instance from the array.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { collect } from "mongoloquent";

    interface IData {
      foo: string;
    }

    const collection = collect<IData>([{foo: "Ajat"}, {foo: "Udin"}])
    .where("foo", "Ajat")
    .map((item) => item.foo.toUpperCase());
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { collect } from "mongoloquent";

    const collection = collect([{foo: "Ajat"}, {foo: "Udin"}])
    .where("name", "Ajat")
    .map((item) => item.foo.toUpperCase());
    ```

  </TabItem>
</Tabs>

As you can see, the `Collection` class allows you to chain its methods to perform fluent mapping and reducing of the underlying array. In general, collections are immutable, meaning every `Collection` method returns an entirely new `Collection` instance.

### Creating Collections

As mentioned above, the `collect` helper returns a new `Collection` instance for the given array. So, creating a collection is as simple as:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { collect } from "mongoloquent";

    interface IData {
      foo: string;
    }

    const collection = collect<IData>([{foo: "Ajat"}, {foo: "Udin"}])
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { collect } from "mongoloquent";

    const collection = collect([{foo: "Ajat"}, {foo: "Udin"}])
    ```

  </TabItem>
</Tabs>

You may also create a collection using the `make` methods.

> The results `Mongoloquent` queries are always returned as `Collection` instances.

## Available Methods

For the majority of the remaining collection documentation, we'll discuss each method available on the `Collection` class. Remember, all of these methods may be chained to fluently manipulate the underlying array. Furthermore, almost every method returns a new `Collection` instance, allowing you to preserve the original copy of the collection when necessary:

## Methods Listing

### after()

The `after` method returns the item after the given item. `null` is returned if the given item is not found or is the last item:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    interface IData {
      foo: number;
    }

    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.after("foo", 3);

    // {foo: 4}

    collection.after("foo", 5);

    // null
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.after("foo", 3);

    // {foo: 4}

    collection.after("foo", 5);

    // null
    ```

  </TabItem>
</Tabs>

This method searches for the given item using "loose" comparison, meaning a string containing an integer value will be considered equal to an integer of the same value. To use "strict" comparison, you may provide the `strict` argument to the method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.after("foo", "4", true);

    // null
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collection.after("foo", "4", true);

    // null
    ```

  </TabItem>
</Tabs>

Alternatively, you may provide your own closure to search for the first item that passes a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.after(function (item) {
      return item.foo > 4;
    });

    // {foo: 5}
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collection.after(function (item) {
      return item.foo > 4;
    });

    // {foo: 5}
    ```

  </TabItem>
</Tabs>

### all()

The `all` method returns the underlying array represented by the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]).all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]).all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>
</Tabs>

### average()

Alias for the `avg` method.

### avg()

The `avg` method returns the average `value` of a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const average = collect<IData>([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).avg("foo");

    // {foo: 20}

    const average  = collect<IData>([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]).avg("foo");

    // {foo: 2}
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const average = collect([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).avg("foo");

    // {foo: 20}

    const average  = collect([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]).avg("foo");

    // {foo: 2}
    ```

  </TabItem>
</Tabs>

### before()

The `before` method is the opposite of the `after` method. It returns the item before the given item. `null` is returned if the given item is not found or is the first item:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.before("foo", 3);

    // {foo: 2}

    collection.before("foo", 1);

    // null

    collection.before("foo", '4', true);

    // null

    collection.before(function (item) {
      return item.foo > 5;
    });

    // {foo: 4}
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.before("foo", 3);

    // {foo: 2}

    collection.before("foo", 1);

    // null

    collection.before("foo", '4', true);

    // null

    collection.before(function (item) {
      return item.foo > 5;
    });

    // {foo: 4}
    ```

  </TabItem>
</Tabs>

### chunk()

The `chunk` method breaks the collection into multiple, smaller collections of a given size:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
    ]);

    const chunkes = collection.chunk(4);

    chunkes.all();

    //   [[{foo: 1}, {foo: 2}, {foo: 3}, {foo: 4}], [{foo: 5}, {foo: 6}, {foo: 7}]],
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
    ]);

    const chunkes = collection.chunk(4);

    chunkes.all();

    //   [[{foo: 1}, {foo: 2}, {foo: 3}, {foo: 4}], [{foo: 5}, {foo: 6}, {foo: 7}]],
    ```

  </TabItem>
</Tabs>

### collect()

The `collect` method returns a new `Collection` instance with the items currently in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collectionA = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]);

    const collectionB = collectionA.collect();

    collectionB.all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collectionA = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]);

    const collectionB = collectionA.collect();

    collectionB.all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>
</Tabs>

### concat()

The concat method appends the given array or collection's values onto the end of another collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([{foo: 1}]);

    const concatenated = collection.concat([
      {foo: 2},
      {foo: 3},
    ]);

    concatenated.all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([{foo: 1}]);

    const concatenated = collection.concat([
      {foo: 2},
      {foo: 3},
    ]);

    concatenated.all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>
</Tabs>

### contains()

The `contains` method determines whether the collection contains a given item. You may pass a closure to the `contains` method to determine if an element exists in the collection matching a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.contains((item) => {
      return item.foo > 5;
    })

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.contains((item) => {
      return item.foo > 5;
    })

    // false
    ```

  </TabItem>
</Tabs>

Alternatively, You may pass a key / value pair to the `contains` method, which will determine if the given pair exists in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {name: "Desk", price: 100}
    ]);

    collection.contains("Desk");

    // true

    collection.contains("New York");

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {name: "Desk", price: 100}
    ]);

    collection.contains("Desk");

    // true

    collection.contains("New York");

    // false
    ```

  </TabItem>
</Tabs>

The `contains` method uses "loose" comparisons when checking item values, meaning a string with an integer value will be considered equal to an integer of the same value. Use the `containsStrict` method to filter using "strict" comparisons.

> For the inverse of `contains`, see the [doesntContain](#doesntcontain) method.

### containsStrict()

This method has the same signature as the `contains` method; however, all values are compared using "strict" comparisons.

### count()

The `count` method returns the total number of items in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    collection.count();

    // 4
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
    ]);

    collection.count();

    // 4
    ```

  </TabItem>
</Tabs>

### countBy()

The `countBy` method counts the occurrences of values in the collection. By default, the method counts the occurrences of every element, allowing you to count certain "types" of elements in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 2},
      {foo: 2},
      {foo: 3},
    ]);

    collection.countBy("foo");

    // {1: 1, 2: 3, 3: 1}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 2},
      {foo: 2},
      {foo: 3},
    ]);

    collection.countBy("foo");

    // {1: 1, 2: 3, 3: 1}
    ```

  </TabItem>
</Tabs>

You may pass a closure to the `countBy` method to count all items by a custom value:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {email: "ajat@gmail.com"},
      {email: "udin@yahoo.com"},
      {email: "kosasih@gamil.com"}
    ]);

    const counted = collection.countBy((item) => {
      return item.email.split("@")[1];
    });

    counted.all();

    // {gmail.com: 2, yahoo.com: 1}
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {email: "ajat@gmail.com"},
      {email: "udin@yahoo.com"},
      {email: "kosasih@gamil.com"}
    ]);

    const counted = collection.countBy((item) => {
      return item.email.split("@")[1];
    });

    counted.all();

    // {gmail.com: 2, yahoo.com: 1}
    ```

  </TabItem>
</Tabs>

### doesntContain()

The `doesntContain` method determines whether the collection does not contain a given item. You may pass a closure to the `doesntContain` method to determine if an element does not exist in the collection matching a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.doesntContain((item) => {
      return item.foo < 5;
    })

    // false
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.doesntContain((item) => {
      return item.foo < 5;
    })

    // false
    ```

  </TabItem>
</Tabs>

Alternatively, You may also pass a key / value pair to the doesntContain method, which will determine if the given pair does not exist in the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {product: "Desk", price: 200}
      {product: "Chair", price: 100}
    ]);

    collection.doesntContain("name", "Bookcase");

    // true
    ```

  </TabItem>

  <TabItem value="Javascript" label="Javascript" default>
    ```javascript
    const collection = collect<IData>([
      {product: "Desk", price: 200}
      {product: "Chair", price: 100}
    ]);

    collection.doesntContain("name", "Bookcase");

    // true
    ```

  </TabItem>
</Tabs>

## Higher Order Messages

## Lazy Collections

### Introduction

### Creating Lazy Collections

### The Enumerable Contract

### Lazy Collection Methods

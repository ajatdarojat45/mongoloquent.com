---
sidebar_position: 2
title: Relationships
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Sponsor from "../sponsor.mdx";

# Mongoloquent: Relationships

## Introduction

Database tables are often related to one another. For example, a blog post may have many comments or an order could be related to the user who placed it. Mongoloquent makes managing and working with these relationships easy, and supports a variety of common relationships:

- [One To One](#one-to-one--has-one)
- [One To Many](#one-to-many--has-many)
- [Many To Many](#many-to-many-relationships)
- [Has Many Through](#has-many-through)
- [One To One (Polymorphic)](#one-to-one-polymorphic)
- [One To Many (Polymorphic)](#one-to-many-polymorphic)
- [Many To Many (Polymorphic)](#many-to-many-polymorphic)

## Defining Relationships

Mongoloquent relationships are defined as methods on your Mongoloquent model classes. Since relationships also serve as powerful [query builders](../database/query-builder), defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional query constraints on this `posts` relationship:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const posts = await user.posts().where('active', true).get();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const posts = await user.posts().where('active', true).get();
    ```

  </TabItem>
</Tabs>

But, before diving too deep into using relationships, let's learn how to define each type of relationship supported by Mongoloquent.

### One to One / Has One

A one-to-one relationship is a very basic type of database relationship. For example, a `User` model might be associated with one `Phone` model. To define this relationship, we will place a `phone` method on the `User` model. The `phone` method should call the `hasOne` method and return its result. The `hasOne` method is available to your model via the model's `Mongoloquent Model` base class:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from "mongoloquent";
    import Phone from './Models/Phone';

    interface IUser extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class User extends Model<IUser> {
      /**
       * The attributes of the model.
       *
       * @var IUser
       */
      static $schema: IUser

      /**
       * Get the phone associated with the user.
       */
      public function phone(){
        return this.hasOne(Phone);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Phone from './Models/Phone';

    class User extends Model {
      /**
       * Get the phone associated with the user.
       */
      public function phone(){
        return this.hasOne(Phone);
      }
    }
    ```

  </TabItem>
</Tabs>

The first argument passed to the `hasOne` method is the name of the related model class. Once the relationship is defined, we may retrieve the related record using Mongoloquent's dynamic methods. Dynamic methods allow you to access relationship methods as if they were methods defined on the model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const phone = await User.find("10ab7e3d05d58a1ad246ee87").phone().first();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const phone = await User.find("10ab7e3d05d58a1ad246ee87").phone().first();
    ```

  </TabItem>
</Tabs>

Mongoloquent determines the foreign key of the relationship based on the parent model name. In this case, the `Phone` model is automatically assumed to have a `userId` foreign key. If you wish to override this convention, you may pass a second argument to the `hasOne` method:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    return this.hasOne(Phone, 'foreign_key');
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    return this.hasOne(Phone, 'foreign_key');
    ```

  </TabItem>
</Tabs>

Additionally, Mongoloquent assumes that the foreign key should have a value matching the primary key column of the parent. In other words, Mongoloquent will look for the value of the user's id column in the `user_id` column of the `Phone` record. If you would like the relationship to use a primary key value other than `_id`, you may pass a third argument to the `hasOne` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    return this.hasOne(Phone, 'foreign_key', 'local_key');
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    return this.hasOne(Phone, 'foreign_key', 'local_key');
    ```

  </TabItem>
</Tabs>

#### Defining the Inverse of the Relationship

So, we can access the `Phone` model from our `User` model. Next, let's define a relationship on the `Phone` model that will let us access the user that owns the phone. We can define the inverse of a `hasOne` relationship using the `belongsTo` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { ObjectID } from 'mongodb';
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from "mongoloquent";
    import User from './Models/User';

    interface IPhone extends IMongoloquentSchema, IMongoloquentTimestamps {
      number: string
      userId: ObjectID
    }

    class Phone extends Model<IPhone> {
      /**
       * The attributes of the model.
       *
       * @var IPhone
       */
      static $schema: IPhone

      /**
       * Get the user that owns the phone.
       */
      public function user(){
        return this.belongsTo(User);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from "mongoloquent";
    import User from './Models/User';

    class Phone extends Model {
      /**
       * Get the user that owns the phone.
       */
      public function user(){
        return this.belongsTo(User);
      }
    }
    ```

  </TabItem>
</Tabs>

When invoking the `user` method, Mongoloquent will attempt to find a `User` model that has an `_id` which matches the `userId` column on the Phone model.

Mongoloquent determines the foreign key name by examining the name of the relationship method and suffixing the method name with `Id`. So, in this case, Mongoloquent assumes that the `Phone` model has a `userId` column. However, if the foreign key on the `Phone` model is not `userId`, you may pass a custom key name as the second argument to the `belongsTo` method:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    /**
     * Get the user that owns the phone.
     */
    public function user(){
      return this.belongsTo(User::class, 'foreign_key');
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    /**
     * Get the user that owns the phone.
     */
    public function user(){
      return this.belongsTo(User::class, 'foreign_key');
    }
    ```

  </TabItem>
</Tabs>

If the parent model does not use `_id` as its primary key, or you wish to find the associated model using a different column, you may pass a third argument to the `belongsTo` method specifying the parent table's custom key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    /**
     * Get the user that owns the phone.
     */
    public function user(){
      return this.belongsTo(User, 'foreign_key', 'owner_key');
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    /**
     * Get the user that owns the phone.
     */
    public function user(){
      return this.belongsTo(User, 'foreign_key', 'owner_key');
    }
    ```

  </TabItem>
</Tabs>

### One to Many / Has Many

A one-to-many relationship is used to define relationships where a single model is the parent to one or more child models. For example, a blog post may have an infinite number of comments. Like all other Mongoloquent relationships, one-to-many relationships are defined by defining a method on your Mongoloquent model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Comment from './Models/Comment';

    interface IPost extends IMongoloquentSchema, IMongoloquentTimestamps {
      title: string
    }

    class Post extends Model<IPost> {
      /**
       * The attributes of the model.
       *
       * @var IPost
       */
      static $schema: IPost

      /**
       * Get the comments for the post.
       */
      public function comments(){
        return this.hasMany(Comment);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Comment from './Models/Comment';

    class Post extends Model {
      /**
       * Get the comments for the post.
       */
      public function comments(){
        return this.hasMany(Comment);
      }
    }
    ```

  </TabItem>
</Tabs>

Remember, Mongoloquent will automatically determine the proper foreign key column for the `Comment` model. By convention, Mongoloquent will take the "camel case" name of the parent model and suffix it with `Id`. So, in this example, Mongoloquent will assume the foreign key column on the `Comment` model is `postId`.

Once the relationship method has been defined, we can access the [collection](./collection) of related `comments` by accessing the comments property. Remember, since Mongoloquent provides "dynamic relationship methods", we can access relationship methods as if they were defined as methods on the model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87")
    const comments = await post.comments().get();

    comments.forEach(comment => {
      console.log(comment.body);
    });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87")
    const comments = await post.comments().get();

    comments.forEach(comment => {
      console.log(comment.body);
    });
    ```

  </TabItem>
</Tabs>

Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `comments` method and continuing to chain conditions onto the query:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments()
      .where('title', 'foo')
      .first();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const post = await Post.find("10ab7e3d05d58a1ad246ee87");
    
    const comment = await post.comments()
      .where('title', 'foo')
      .first();
    ```

  </TabItem>
</Tabs>

Like the `hasOne` method, you may also override the foreign and local keys by passing additional arguments to the `hasMany` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    return this.hasMany(Comment, 'foreign_key');

    return this.hasMany(Comment, 'foreign_key', 'local_key');
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    return this.hasMany(Comment, 'foreign_key');

    return this.hasMany(Comment, 'foreign_key', 'local_key');
    ```

  </TabItem>
</Tabs>

### One to Many (Inverse) / Belongs To

Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a `hasMany` relationship, define a relationship method on the child model which calls the `belongsTo` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Post from './Models/Post';

    interface IComment extends IMongoloquentSchema, IMongoloquentTimestamps {
      body: string
      postId: ObjectID
    }

    class Comment extends Model<IComment> {
      /**
       * The attributes of the model.
       *
       * @var IComment
       */
      static $schema: IComment

      /**
       * Get the post that owns the comment.
       */
      public function post(){
        return this.belongsTo(Post);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Post from './Models/Post';

    class Comment extends Model {
      /**
       * Get the post that owns the comment.
       */
      public function post(){
        return this.belongsTo(Post);
      }
    }
    ```

  </TabItem>
</Tabs>

Once the relationship has been defined, we can retrieve a comment's parent `post` by accessing the post "dynamic relationship method":

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    import Comment from './Models/Comment';

    const comment = await Comment.find("10ab7e3d05d58a1ad246ee87");

    const post = await comment.post().first();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Comment from './Models/Comment';

    const comment = await Comment.find("10ab7e3d05d58a1ad246ee87");

    const post = await comment.post().first();
    ```

  </TabItem>
</Tabs>

In the example above, Mongoloquent will attempt to find a `Post` model that has an `_id` which matches the `postId` column on the `Comment` model.

Mongoloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name followed by the name of the parent model's primary key column. So, in this example, Mongoloquent will assume the `Post` model's foreign key on the `comments` table is `postId`.

However, if the foreign key for your relationship does not follow these conventions, you may pass a custom foreign key name as the second argument to the `belongsTo` method:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    /**
     * Get the post that owns the comment.
     */
    public function post(){
      return this.belongsTo(Post, 'foreign_key');
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    /**
     * Get the post that owns the comment.
     */
    public function post(){
      return this.belongsTo(Post, 'foreign_key');
    }
    ```

  </TabItem>
</Tabs>

If your parent model does not use `_id` as its primary key, or you wish to find the associated model using a different column, you may pass a third argument to the `belongsTo` method specifying your parent table's custom key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    /**
     * Get the post that owns the comment.
     */
    public function post(){
      return this.belongsTo(Post, 'foreign_key', 'owner_key');
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    /**
     * Get the post that owns the comment.
     */
    public function post(){
      return this.belongsTo(Post, 'foreign_key', 'owner_key');
    }
    ```

  </TabItem>
</Tabs>

### Has Many Through

The "has-many-through" relationship provides a convenient way to access distant relations via an intermediate relation. For example, let's assume we are building a deployment platform. An `Application` model might access many `Deployment` models through an intermediate `Environment` model. Using this example, you could easily gather all deployments for a given application. Let's look at the tables required to define this relationship:

```
applications
  _id - ObjectID
  name - string

environments
  _id - ObjectID
  applicationId - ObjectID
  name - string

deployments
  _id - ObjectID
  environmentId - ObjectID
  commit_hash - string
```

Now that we have examined the table structure for the relationship, let's define the relationship on the `Application` model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Deployment from './Models/Deployment';
    import Environment from './Models/Environment';

    interface IApplication extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class Application extends Model<IApplication> {
      /**
       * Get all of the deployments for the application.
       */
      public function deployments(){
        return this.hasManyThrough(Deployment, Environment);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Deployment from './Models/Deployment';
    import Environment from './Models/Environment';

    class Application extends Model {
      /**
       * Get all of the deployments for the application.
       */
      public function deployments(){
        return this.hasManyThrough(Deployment, Environment);
      }
    }
    ```

  </TabItem>
</Tabs>

The first argument passed to the `hasManyThrough` method is the name of the final model we wish to access, while the second argument is the name of the intermediate model.

#### Key Conventions

Typical Mongoloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the `hasManyThrough` method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    class Application extends Model{

      public function deployments(){
        return this.hasManyThrough(
          Deployment,
          Environment,
          'applicationId', // Foreign key on the environments table...
          'environmentId', // Foreign key on the deployments table...
          '_id', // Local key on the applications table...
          '_id' // Local key on the environments table...
        );
      }

    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    class Application extends Model{

      public function deployments(){
        return this.hasManyThrough(
          Deployment,
          Environment,
          'applicationId', // Foreign key on the environments table...
          'environmentId', // Foreign key on the deployments table...
          '_id', // Local key on the applications table...
          '_id' // Local key on the environments table...
        );
      }

    }
    ```

  </TabItem>
</Tabs>

### Scoped Relationships

It's common to add additional methods to models that constrain relationships. For example, you might add a `featuredPosts` method to a `User` model which constrains the broader `posts` relationship with an additional `where` constraint:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Post from './Models/Post';

    interface IUser extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class User extends Model<IUser> {
      /**
       * The attributes of the model.
       *
       * @var IUser
       */
      static $schema: IUser

      /**
       * Get all of the user's posts.
       */
      public function posts(){
        return this.hasMany(Post, 'foreign_key');
      }

      /**
       * Get all of the user's featured posts.
       */
      public function featuredPosts(){
        return this.posts().where('featured', true);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Post from './Models/Post';

    class User extends Model {
      /**
       * Get all of the user's posts.
       */
      public function posts(){
        return this.hasMany(Post, 'foreign_key');
      }

      /**
       * Get all of the user's featured posts.
       */
      public function featuredPosts(){
        return this.posts().where('featured', true);
      }
    }
    ```

  </TabItem>
</Tabs>

## Many to Many Relationships

Many-to-many relations are slightly more complicated than `hasOne` and `hasMany` relationships. An example of a many-to-many relationship is a user that has many roles and those roles are also shared by other users in the application. For example, a user may be assigned the role of "Author" and "Editor"; however, those roles may also be assigned to other users as well. So, a user has many roles and a role has many users.

#### Table Structure

To define this relationship, three database tables are needed: `users`, `roles`, and `roleUser`. The `roleUser` table is derived from the alphabetical order of the related model names and contains `userId` and `roleId` columns. This table is used as an intermediate table linking the users and roles.

Remember, since a role can belong to many users, we cannot simply place a `userId` column on the `roles` table. This would mean that a role could only belong to a single user. In order to provide support for roles being assigned to multiple users, the `roleUser` table is needed. We can summarize the relationship's table structure like so:

```
users
  _id - ObjectID
  name - string

roles
  _id - ObjectID
  name - string

roleUser
  userId - ObjectID
  roleId - ObjectID
```

#### Model Structure

Many-to-many relationships are defined by writing a method that returns the result of the `belongsToMany` method. The `belongsToMany` method is provided by the `Model` base class that is used by all of your application's Mongoloquent models. For example, let's define a `roles` method on our `User` model. The first argument passed to this method is the name of the related model class:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Role from './Models/Role';

    interface IUser extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class User extends Model<IUser> {
      /**
       * The roles that belong to the user.
       */
      public function roles(){
        return this.belongsToMany(Role);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Mongoloquent } from 'mongoloquent';
    import Role from './Models/Role';

    class User extends Mongoloquent {
      /**
       * The roles that belong to the user.
       */
      public function roles(){
        return this.belongsToMany(Role);
      }
    }
    ```

  </TabItem>
</Tabs>

Once the relationship is defined, you may access the user's `roles` using the roles dynamic relationship property:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import User from './Models/User';

    const user = await User.find("10ab7e3d05d58a1ad246ee87");

    const roles = await user.roles().get();

    roles.forEach(role => {
      console.log(role.name);
    });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import User from './Models/User';

    const user = await User.find("10ab7e3d05d58a1ad246ee87");

    const roles = await user.roles().get();

    roles.forEach(role => {
      console.log(role.name);
    });
    ```

  </TabItem>
</Tabs>

Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `roles` method and continuing to chain conditions onto the query:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const user = await User.find("10ab7e3d05d58a1ad246ee87");
    
    const roles = await user.orderBy('name').get();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const user = await User.find("10ab7e3d05d58a1ad246ee87");
    
    const roles = await user.orderBy('name').get();
    ```

  </TabItem>
</Tabs>

To determine the table name of the relationship's intermediate table, Mongoloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the `belongsToMany` method:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    return this.belongsToMany(Role, "roleUser");
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    return this.belongsToMany(Role, "roleUser");
    ```

  </TabItem>
</Tabs>

In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on the table by passing additional arguments to the `belongsToMany` method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to:

<Tabs>
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript
    return this.belongsToMany(Role, "roleUser", "userId", "roleId");
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    return this.belongsToMany(Role, "roleUser", "userId", "roleId");
    ```

  </TabItem>  
</Tabs>

#### Defining the Inverse of the Relationship

To define the "inverse" of a many-to-many relationship, you should define a method on the related model which also returns the result of the `belongsToMany` method. To complete our user / role example, let's define the `users` method on the `Role` model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import User from './Models/User';

    interface IRole extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class Role extends Model<IRole> {
      /**
       * The attributes of the model.
       *
       * @var IRole
       */
      static $schema: IRole

      /**
       * The users that belong to the role.
       */
      public function users(){
        return this.belongsToMany(User);
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import User from './Models/User';

    class Role extends Model {
      /**
       * The users that belong to the role.
       */
      public function users(){
        return this.belongsToMany(User);
      }
    }
    ```

  </TabItem>
</Tabs>

As you can see, the relationship is defined exactly the same as its `User` model counterpart with the exception of referencing the `Models/User` model. Since we're reusing the `belongsToMany` method, all of the usual table and key customization options are available when defining the "inverse" of many-to-many relationships.

## Polymorphic Relationships

A polymorphic relationship allows the child model to belong to more than one type of model using a single association. For example, imagine you are building an application that allows users to share blog posts and videos. In such an application, a `Comment` model might belong to both the `Post` and `Video` models.

### One to One (Polymorphic)

#### Table Structure

A one-to-one polymorphic relation is similar to a typical one-to-one relation; however, the child model can belong to more than one type of model using a single association. For example, a blog `Post` and a `User` may share a polymorphic relation to an `Image` model. Using a one-to-one polymorphic relation allows you to have a single table of unique images that may be associated with posts and users. First, let's examine the table structure:

```
posts
  _id - ObjectID
  name - string

users
  _id - ObjectID
  name - string

images
  _id - ObjectID
  url - string
  imageableId - ObjectID
  imageableType - string
```

Note the `imageableId` and `imageableType` columns on the `images` collection. The `imageableId` column will contain the ID value of the post or user, while the `imageableType` column will contain the class name of the parent model. The `imageableType` column is used by Mongoloquent to determine which "type" of parent model to return when accessing the `imageable` relation. In this case, the column would contain either `Post` or `User`.

#### Model Structure

Next, let's examine the model definitions needed to build this relationship:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    // Image.ts
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';

    interface IImage, IMongoloquentSchema, IMongoloquentTimestamps {
      url: string
      imageableId: ObjectID
      imageableType: string
    }

    class Image extends Model<IImage> {
      /**
       * The attributes of the model.
       *
       * @var IImage
       */
      static $schema: IImage

      /**
       * The collection name.
       *
       * @var string
       */
      static $collection: string = 'imagables';
    }


    // Post.ts
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Image from './Models/Image';

    interface IPost extends IMongoloquentSchema, IMongoloquentTimestamps {
      title: string
    }

    class Post extends Model<IPost> {
      /**
       * The attributes of the model.
       *
       * @var IPost
       */
      static $schema: IPost

      /**
       * The collection name.
       *
       * @var string
       */
      static $collection: string = 'posts';

      /**
       * Get the post's image.
       */
      public function image(){
        return this.morphTo(Image, 'imageable');
      }
    }


    // User.ts
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Image from './Models/Image';

    interface IUser extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class User extends Model<IUser> {
      /**
       * The attributes of the model.
       *
       * @var IUser
       */
      static $schema: IUser

      /**
       * The collection name.
       *
       * @var string
       */
      static $collection: string = 'users';

      /**
       * Get the user's image.
       */
      public function image(){
        return this.morphTo(Image, 'imageable');
      }
    }

    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    // Image.js
    import { Model } from 'mongoloquent';

    class Image extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'imagables';
    }


    // Post.js
    import { Model } from 'mongoloquent';
    import Image from './Models/Image';

    class Post extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'posts';

      /**
       * Get the post's image.
       */
      public function image(){
        return this.morphTo(Image, 'imageable');
      }
    }


    // User.js
    import { Model } from 'mongoloquent';
    import Image from './Models/Image';

    class User extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'users';

      /**
       * Get the user's image.
       */
      public function image(){
        return this.morphTo(Image, 'imageable');
      }
    }
    ```

  </TabItem>
</Tabs>

#### Retrieving the Relationship

Once your database table and models are defined, you may access the relationships via your models. For example, to retrieve the image for a post, we can access the `image` dynamic relationship property:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const image = await post.image().first();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const image = await post.image().first();
    ```

  </TabItem>
</Tabs>

### One to Many (Polymorphic)

A one-to-many polymorphic relation is similar to a typical one-to-many relation; however, the child model can belong to more than one type of model using a single association. For example, imagine users of your application can "comment" on posts and videos. Using polymorphic relationships, you may use a single `comments` table to contain comments for both posts and videos. First, let's examine the table structure required to build this relationship:

```
posts
  _id - ObjectID
  title - string
  body - text

videos
  _id - ObjectID
  title - string
  url - string

comments
  _id - ObjectID
  body - text
  commentableId - ObjectID
  commentableType - string
```

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    // Comment.ts
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import { ObjectID } from "mongodb"

    interface IComment extends IMongoloquentSchema, IMongoloquentTimestamps {
      body: string
      commentableId: ObjectID
      commentableType: string
    }

    class Comment extends Model<IComment> {
      /**
       * The attributes of the model.
       *
       * @var IComment
       */
      static $schema: IComment

      /**
       * The collection name.
       *
       * @var string
       */
      protected static $collection: string = 'comments';
    }


    // Post.ts
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Comment from './Models/Comment';

    interface IPost extends IMongoloquentSchema, IMongoloquentTimestamps {
      title: string
      body: string
    }

    class Post extends Model<IPost> {
      /**
       * The attributes of the model.
       *
       * @var IPost
       */
      static $schema: IPost

      /**
       * The collection name.
       *
       * @var string
       */
      protected static $collection: string = 'posts';

      /**
       * Get all of the post's comments.
       */
      public function comments(){
        return this.morphMany(Comment, 'commentable');
      }
    }


    // Video.ts
    import { Model } from 'mongoloquent';
    import Comment from './Models/Comment';

    interface IVideo extends IMongoloquentSchema, IMongoloquentTimestamps {
      title: string
      url: string
    }

    class Video extends Model<IVideo> {
      /**
       * The attributes of the model.
       *
       * @var IVideo
       */
      static $schema: IVideo

      /**
       * The collection name.
       *
       * @var string
       */
      protected static $collection: string = 'videos';

      /**
       * Get all of the video's comments.
       */
      public function comments(){
        return this.morphMany(Comment, 'commentable');
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    // Comment.js
    import { Model } from 'mongoloquent';

    class Comment extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'comments';
    }


    // Post.js
    import { Model } from 'mongoloquent';
    import Comment from './Models/Comment';

    class Post extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'posts';

      /**
       * Get all of the post's comments.
       */
      public function comments(){
        return this.morphMany(Comment, 'commentable');
      }
    }


    // Video.js
    import { Model } from 'mongoloquent';
    import Comment from './Models/Comment';

    class Video extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'videos';

      /**
       * Get all of the video's comments.
       */
      public function comments(){
        return this.morphMany(Comment, 'commentable');
      }
    }
    ```

  </TabItem>
</Tabs>

#### Retrieving the Relationship

Once your database table and models are defined, you may access the relationships via your model's dynamic relationship properties. For example, to access all of the comments for a post, we can use the `comments` dynamic property:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const comments = await post.comments().get();

    comments.forEach(comment => {
      console.log(comment.body);
    });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const comments = await post.comments().get();

    comments.forEach(comment => {
      console.log(comment.body);
    });
    ```

  </TabItem>
</Tabs>

### Many to Many (Polymorphic)

#### Table Structure

Many-to-many polymorphic relations are slightly more complicated than "morph one" and "morph many" relationships. For example, a `Post` model and `Video` model could share a polymorphic relation to a `Tag` model. Using a many-to-many polymorphic relation in this situation would allow your application to have a single table of unique tags that may be associated with posts or videos. First, let's examine the table structure required to build this relationship:

```
posts
  _id - ObjectID
  name - string

videos
  _id - ObjectID
  name - string

tags
  _id - ObjectID
  name - string

taggables
  _id - ObjectID
  tag_id - ObjectID
  taggableId - ObjectID
  taggableType - string

```

> Before diving into polymorphic many-to-many relationships, you may benefit from reading the documentation on typical [many-to-many relationships](#many-to-many-relationships).

#### Model Structure

Next, we're ready to define the relationships on the models. The `Post` and `Video` models will both contain a `tags` method that calls the `morphToMany` method provided by the base Eloquent model class.

The `morphToMany` method accepts the name of the related model as well as the "relationship name". Based on the name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as "taggable":

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Tag from './Models/Tag';

    interface IPost extends IMongoloquentSchema, IMongoloquentTimestamps {
      title: string
      body: string
    }

    class Post extends Model<IPost> {
      /**
       * The attributes of the model.
       *
       * @var IPost
       */
      static $schema: IPost

      /**
       * The collection name.
       *
       * @var string
       */
      protected static $collection: string = 'posts';

      /**
       * Get all of the tags for the post.
       */
      public function tags(){
        return this.morphToMany(Tag, 'taggable');
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Tag from './Models/Tag';

    class Post extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'posts';

      /**
       * Get all of the tags for the post.
       */
      public function tags(){
        return this.morphToMany(Tag, 'taggable');
      }
    }
    ```

  </TabItem>
</Tabs>

#### Defining the Inverse of the Relationship

Next, on the `Tag` model, you should define a method for each of its possible parent models. So, in this example, we will define a `posts` method and a `videos` method. Both of these methods should return the result of the `morphedByMany` method.

The `morphedByMany` method accepts the name of the related model as well as the "relationship name". Based on the name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as "taggable":

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import Post from './Models/Post';
    import Video from './Models/Video';

    interface ITag extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class Tag extends Model<ITag> {
      /**
       * The attributes of the model.
       *
       * @var ITag
       */
      static $schema: ITag

      /**
       * The collection name.
       *
       * @var string
       */
      static $collection: string = 'tags';

      /**
       * Get all of the posts that are tagged with the tag.
       */
      public function posts(){
        return this.morphedByMany(Post, 'taggable');
      }

      /**
       * Get all of the videos that are tagged with the tag.
       */
      public function videos(){
        return this.morphedByMany(Video, 'taggable');
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Post from './Models/Post';
    import Video from './Models/Video';

    class Tag extends Model {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'tags';

      /**
       * Get all of the posts that are tagged with the tag.
       */
      public function posts(){
        return this.morphedByMany(Post, 'taggable');
      }

      /**
       * Get all of the videos that are tagged with the tag.
       */
      public function videos(){
        return this.morphedByMany(Video, 'taggable');
      }
    }
    ```

  </TabItem>
</Tabs>

#### Retrieving the Relationship

Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you may use the `tags` dynamic relationship method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const tags = await post.tags().get();

    tags.forEach(tag => {
      console.log(tag.name);
    });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = await Post.find("10ab7e3d05d58a1ad246ee87");

    const tags = await post.tags().get();

    tags.forEach(tag => {
      console.log(tag.name);
    });
    ```

  </TabItem>
</Tabs>

You may retrieve the parent of a polymorphic relation from the polymorphic child model by accessing the name of the method that performs the call to `morphedByMany`. In this case, that is the `posts` or `videos` methods on the `Tag` model:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Tag from './Models/Tag';

    const tag = await Tag.find("10ab7e3d05d58a1ad246ee87");

    const posts = await tag.posts().get();

    posts.forEach(post => {
      console.log(post.title);
    });

    const videos = await tag.videos().get();

    videos.forEach(video => {
      console.log(video.title);
    });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Tag from './Models/Tag';

    const tag = await Tag.find("10ab7e3d05d58a1ad246ee87");

    const posts = await tag.posts().get();

    posts.forEach(post => {
      console.log(post.title);
    });

    const videos = await tag.videos().get();

    videos.forEach(video => {
      console.log(video.title);
    });
    ```

  </TabItem>
</Tabs>

## Querying Relationships

Since all Mongoloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing a query to load the related models. In addition, all types of Mongoloquent relationships also serve as [query builders](../database/query-builder), allowing you to continue to chain constraints onto the relationship query before finally executing the SQL query against your database.

For example, imagine a blog application in which a `User` model has many associated `Post` models:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';

    interface IUser extends IMongoloquentSchema, IMongoloquentTimestamps {
      name: string
    }

    class User extends Model<IUser> {
      /**
       * The attributes of the model.
       *
       * @var IUser
       */
      static $schema: IUser

      /**
       * The collection name.
       *
       * @var string
       */
      static $collection: string = 'users';

      /**
       * Get all of the posts for the user.
       */
      public function posts(){
        return this.hasMany(Post, 'foreign_key');
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';

    class User extends Mongoloquent {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'users';

      /**
       * Get all of the posts for the user.
       */
      public function posts(){
        return this.hasMany(Post, 'foreign_key');
      }
    }

    ```

  </TabItem>
</Tabs>

You may query the `posts` relationship and add additional constraints to the relationship like so:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import User from './Models/User';

    const user = User.find("10ab7e3d05d58a1ad246ee87");

    const posts = await user.posts().where('active', true).get();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import User from './Models/User';

    const user = User.find("10ab7e3d05d58a1ad246ee87");

    const posts = await user.posts().where('active', true).get();
    ```

  </TabItem>
</Tabs>

You are able to use any of the Mongoloquent [query builders](../database/query-builder) methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you.

#### Chaining `orWhere` Clauses After Relationships

As demonstrated in the example above, you are free to add additional constraints to relationships when querying them. However, use caution when chaining `orWhere` clauses onto a relationship, as the `orWhere` clauses will be logically grouped at the same level as the relationship constraint:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const posts = await user.posts()
      .where('active', true)
      .orWhere('votes', '>=', 100)
      .get();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const posts = await user.posts()
      .where('active', true)
      .orWhere('votes', '>=', 100)
      .get();
    ```

  </TabItem>
</Tabs>

## Eager Loading

Mongoloquent can "eager load" relationships at the time you query the parent model. Eager loading alleviates the "N + 1" query problem.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { Model, IMongoloquentSchema, IMongoloquentTimestamps } from 'mongoloquent';
    import { ObjectID } from "mongodb"
    import Author from './Models/Author';

    interface IBook extends IMongoloquentSchema, IMongoloquentTimestamps {
      title: string
      authorId: ObjectID
    }

    class Book extends Mongoloquent {
      /**
       * The attributes of the model.
       *
       * @var IBook
       */
      static $schema: IBook

      /**
       * The collection name.
       *
       * @var string
       */
      protected static $collection: string = 'books';

      /**
       * Get the author that wrote the book.
       */
      public function author(){
        return this.belongsTo(Author, 'foreign_key');
      }
    }
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { Model } from 'mongoloquent';
    import Author from './Models/Author';

    class Book extends Mongoloquent {
      /**
       * The collection name.
       *
       * @var string
       */
      static $collection = 'books';

      /**
       * Get the author that wrote the book.
       */
      public function author(){
        return this.belongsTo(Author, 'foreign_key');
      }
    }
    ```

  </TabItem>
</Tabs>

We can use eager loading to reduce this operation to just two queries. When building a query, you may specify which relationships should be eager loaded using the `with` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Book from './Models/Book';

    const books = await Book.with('author').get();

    books.forEach(book => {
      console.log(book.author.name);
    });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Book from './Models/Book';

    const books = await Book.with('author').get();

    books.forEach(book => {
      console.log(book.author.name);
    });
    ```

  </TabItem>
</Tabs>

#### Eager Loading Multiple Relationships

Sometimes you may need to eager load several different relationships.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Book from './Models/Book';

    const books = await Book.with('author').with('publisher').get();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Book from './Models/Book';

    const books = await Book.with('author').with('publisher').get();
    ```

  </TabItem>
</Tabs>

## Inserting and Updating Related Models

### The `save` Method

Mongoloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to add a new comment to a post. Instead of manually setting the `post_id` attribute on the `Comment` model you may insert the comment using the relationship's `save` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().save({ message: 'A new comment.' });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().save({ message: 'A new comment.' });
    ```

  </TabItem>
</Tabs>

If you need to save multiple related models, you may use the `saveMany` method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().saveMany([
      { message: 'A new comment.' },
      { message: 'Another new comment.' }
    ]);
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().saveMany([
      { message: 'A new comment.' },
      { message: 'Another new comment.' }
    ]);
    ```

  </TabItem>
</Tabs>

### The `create` Method

In addition to the `save` and `saveMany` methods, you may also use the create method, which accepts an array of attributes, creates a model, and inserts it into the database.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().create({ message: 'A new comment.' });
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().create({ message: 'A new comment.' });
    ```

  </TabItem>
</Tabs>

You may use the `createMany` method to create multiple related models:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().createMany([
      { message: 'A new comment.' },
      { message: 'Another new comment.' }
    ]);
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import Post from './Models/Post';

    const post = Post.find("10ab7e3d05d58a1ad246ee87");

    const comment = await post.comments().createMany([
      { message: 'A new comment.' },
      { message: 'Another new comment.' }
    ]);
    ```

  </TabItem>
</Tabs>

### Many to Many Relationships

#### Attaching / Detaching

Mongoloquent also provides methods to make working with many-to-many relationships more convenient. For example, let's imagine a user can have many roles and a role can have many users. You may use the attach method to `attach` a role to a user by inserting a record in the relationship's intermediate collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import User from './Models/User';

    const user = User.find("10ab7e3d05d58a1ad246ee87");

    await user.roles().attach("10ab7e3d05d58a1ad246ee87");
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import User from './Models/User';

    const user = User.find("10ab7e3d05d58a1ad246ee87");

    await user.roles().attach("10ab7e3d05d58a1ad246ee87");
    ```

  </TabItem>
</Tabs>

Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the `detach` method. The `detach` method will delete the appropriate record out of the intermediate table; however, both models will remain in the database:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    // Detach a single role from the user...
    await user.roles().detach("10ab7e3d05d58a1ad246ee87");
    
    // Detach all roles from the user...
    await user.roles().detach();
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    // Detach a single role from the user...
    await user.roles().detach("10ab7e3d05d58a1ad246ee87");

    // Detach all roles from the user...
    await user.roles().detach();
    ```

  </TabItem>
</Tabs>

For convenience, `attach` and `detach` also accept arrays of IDs as input:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const user = User.find("10ab7e3d05d58a1ad246ee87");

    await user.roles().detach([
      "10ab7e3d05d58a1ad246ee87",
      "10ab7e3d05d58a1ad246ee88"
    ]);

    await user.roles().attach([
      "10ab7e3d05d58a1ad246ee87",
      "10ab7e3d05d58a1ad246ee88"
    ]);
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const user = User.find("10ab7e3d05d58a1ad246ee87");

    await user.roles().detach([
      "10ab7e3d05d58a1ad246ee87",
      "10ab7e3d05d58a1ad246ee88"
    ]);

    await user.roles().attach([
      "10ab7e3d05d58a1ad246ee87",
      "10ab7e3d05d58a1ad246ee88"
    ]);
    ```

  </TabItem>
</Tabs>

#### Syncing Associations

You may also use the `sync` method to construct many-to-many associations. The `sync` method accepts an array of IDs to place on the intermediate collection. Any IDs that are not in the given array will be removed from the intermediate collection. So, after this operation is complete, only the IDs in the given array will exist in the intermediate collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    await user.roles().sync([
      "10ab7e3d05d58a1ad246ee87",
      "10ab7e3d05d58a1ad246ee88"
    ]);
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    await user.roles().sync([
      "10ab7e3d05d58a1ad246ee87",
      "10ab7e3d05d58a1ad246ee88"
    ]);
    ```

  </TabItem>
</Tabs>

---

<Sponsor />

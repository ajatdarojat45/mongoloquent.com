---
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Sponsor from "./sponsor.mdx";

# Collections

## Introduction

The `Collection` class provides a fluent, convenient wrapper for working with arrays of data. For example, check out the following code. We'll use the collect helper to create a new collection instance from the array.

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { collect } from "mongoloquent";

    interface IData {
      foo: string;
    }

    const collection = collect<IData>([{foo: "Ajat"}, {foo: "Udin"}])
    .where("foo", "Ajat")
    .map((item) => item.foo.toUpperCase());
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { collect } from "mongoloquent";

    const collection = collect([{foo: "Ajat"}, {foo: "Udin"}])
    .where("name", "Ajat")
    .map((item) => item.foo.toUpperCase());
    ```

  </TabItem>
</Tabs>

As you can see, the `Collection` class allows you to chain its methods to perform fluent mapping and reducing of the underlying array. In general, collections are immutable, meaning every `Collection` method returns an entirely new `Collection` instance.

### Creating Collections

As mentioned above, the `collect` helper returns a new `Collection` instance for the given array. So, creating a collection is as simple as:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    import { collect } from "mongoloquent";

    interface IData {
      foo: string;
    }

    const collection = collect<IData>([{foo: "Ajat"}, {foo: "Udin"}])
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    import { collect } from "mongoloquent";

    const collection = collect([{foo: "Ajat"}, {foo: "Udin"}])
    ```

  </TabItem>
</Tabs>

You may also create a collection using the `make` methods.

> The results `Mongoloquent` queries are always returned as `Collection` instances.

## Available Methods

For the majority of the remaining collection documentation, we'll discuss each method available on the `Collection` class. Remember, all of these methods may be chained to fluently manipulate the underlying array. Furthermore, almost every method returns a new `Collection` instance, allowing you to preserve the original copy of the collection when necessary:

## Methods Listing

### after()

The `after` method returns the item after the given item. `null` is returned if the given item is not found or is the last item:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    interface IData {
      foo: number;
    }

    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.after("foo", 3);

    // {foo: 4}

    collection.after("foo", 5);

    // null
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.after("foo", 3);

    // {foo: 4}

    collection.after("foo", 5);

    // null
    ```

  </TabItem>
</Tabs>

This method searches for the given item using "loose" comparison, meaning a string containing an integer value will be considered equal to an integer of the same value. To use "strict" comparison, you may provide the `strict` argument to the method:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.after("foo", "4", true);

    // null
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collection.after("foo", "4", true);

    // null
    ```

  </TabItem>
</Tabs>

Alternatively, you may provide your own closure to search for the first item that passes a given truth test:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collection.after(function (item) {
      return item.foo > 4;
    });

    // {foo: 5}
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collection.after(function (item) {
      return item.foo > 4;
    });

    // {foo: 5}
    ```

  </TabItem>
</Tabs>

### all()

The `all` method returns the underlying array represented by the collection:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]).all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
    ]).all();

    // [{foo: 1}, {foo: 2}, {foo: 3}]
    ```

  </TabItem>
</Tabs>

### average()

Alias for the `avg` method.

### avg()

The `avg` method returns the average `value` of a given key:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const average = collect<IData>([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).avg("foo");

    // {foo: 20}

    const average  = collect<IData>([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]).avg("foo");

    // {foo: 2}
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const average = collect([
      {foo: 10},
      {foo: 10},
      {foo: 20},
      {foo: 40},
    ]).avg("foo");

    // {foo: 20}

    const average  = collect([
      {foo: 1},
      {foo: 1},
      {foo: 2},
      {foo: 4},
    ]).avg("foo");

    // {foo: 2}
    ```

  </TabItem>
</Tabs>

### before()

The `before` method is the opposite of the `after` method. It returns the item before the given item. `null` is returned if the given item is not found or is the first item:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.before("foo", 3);

    // {foo: 2}

    collection.before("foo", 1);

    // null

    collection.before("foo", '4', true);

    // null

    collection.before(function (item) {
      return item.foo > 5;
    });

    // {foo: 4}
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
    ]);

    collection.before("foo", 3);

    // {foo: 2}

    collection.before("foo", 1);

    // null

    collection.before("foo", '4', true);

    // null

    collection.before(function (item) {
      return item.foo > 5;
    });

    // {foo: 4}
    ```

  </TabItem>
</Tabs>

### chunk()

The `chunk` method breaks the collection into multiple, smaller collections of a given size:

<Tabs>
	<TabItem value="Typescript" label="Typescript" default>
    ```typescript
    const collection = collect<IData>([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
    ]);

    const chunkes = collection.chunk(4);

    chunkes.all();

    //   [[{foo: 1}, {foo: 2}, {foo: 3}, {foo: 4}], [{foo: 5}, {foo: 6}, {foo: 7}]],
    ```

  </TabItem>
  <TabItem value="Javascript" label="Javascript">
    ```javascript
    const collection = collect([
      {foo: 1},
      {foo: 2},
      {foo: 3},
      {foo: 4},
      {foo: 5},
      {foo: 6},
      {foo: 7},
    ]);

    const chunkes = collection.chunk(4);

    chunkes.all();

    //   [[{foo: 1}, {foo: 2}, {foo: 3}, {foo: 4}], [{foo: 5}, {foo: 6}, {foo: 7}]],
    ```

  </TabItem>
</Tabs>

## Higher Order Messages

## Lazy Collections

### Introduction

### Creating Lazy Collections

### The Enumerable Contract

### Lazy Collection Methods
